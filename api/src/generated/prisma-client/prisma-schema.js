module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `enum Action {
  MOVE_UP
  MOVE_LEFT
  MOVE_DOWN
  MOVE_RIGHT
  ATTACK_UP
  ATTACK_LEFT
  ATTACK_DOWN
  ATTACK_RIGHT
  TRANSFORM_NORMAL
  TRANSFORM_FIRE
  TRANSFORM_WATER
  TRANSFORM_GRASS
}

enum ActionType {
  MOVE
  COLLECT
  TRANSFORM
  ATTACK
  RESTORE_HP
  WAIT
}

type Agent {
  id: ID!
  name: String!
  script: String
  className: String
  hostGames(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
  guestGames(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
  winnedGames(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
}

type AgentConnection {
  pageInfo: PageInfo!
  edges: [AgentEdge]!
  aggregate: AggregateAgent!
}

input AgentCreateInput {
  id: ID
  name: String!
  script: String
  className: String
  hostGames: GameCreateManyWithoutHostInput
  guestGames: GameCreateManyWithoutGuestInput
  winnedGames: GameCreateManyWithoutWinnerInput
}

input AgentCreateOneInput {
  create: AgentCreateInput
  connect: AgentWhereUniqueInput
}

input AgentCreateOneWithoutGuestGamesInput {
  create: AgentCreateWithoutGuestGamesInput
  connect: AgentWhereUniqueInput
}

input AgentCreateOneWithoutHostGamesInput {
  create: AgentCreateWithoutHostGamesInput
  connect: AgentWhereUniqueInput
}

input AgentCreateOneWithoutWinnedGamesInput {
  create: AgentCreateWithoutWinnedGamesInput
  connect: AgentWhereUniqueInput
}

input AgentCreateWithoutGuestGamesInput {
  id: ID
  name: String!
  script: String
  className: String
  hostGames: GameCreateManyWithoutHostInput
  winnedGames: GameCreateManyWithoutWinnerInput
}

input AgentCreateWithoutHostGamesInput {
  id: ID
  name: String!
  script: String
  className: String
  guestGames: GameCreateManyWithoutGuestInput
  winnedGames: GameCreateManyWithoutWinnerInput
}

input AgentCreateWithoutWinnedGamesInput {
  id: ID
  name: String!
  script: String
  className: String
  hostGames: GameCreateManyWithoutHostInput
  guestGames: GameCreateManyWithoutGuestInput
}

type AgentEdge {
  node: Agent!
  cursor: String!
}

enum AgentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  script_ASC
  script_DESC
  className_ASC
  className_DESC
}

type AgentPreviousValues {
  id: ID!
  name: String!
  script: String
  className: String
}

type AgentSubscriptionPayload {
  mutation: MutationType!
  node: Agent
  updatedFields: [String!]
  previousValues: AgentPreviousValues
}

input AgentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AgentWhereInput
  AND: [AgentSubscriptionWhereInput!]
}

input AgentUpdateDataInput {
  name: String
  script: String
  className: String
  hostGames: GameUpdateManyWithoutHostInput
  guestGames: GameUpdateManyWithoutGuestInput
  winnedGames: GameUpdateManyWithoutWinnerInput
}

input AgentUpdateInput {
  name: String
  script: String
  className: String
  hostGames: GameUpdateManyWithoutHostInput
  guestGames: GameUpdateManyWithoutGuestInput
  winnedGames: GameUpdateManyWithoutWinnerInput
}

input AgentUpdateManyMutationInput {
  name: String
  script: String
  className: String
}

input AgentUpdateOneRequiredInput {
  create: AgentCreateInput
  update: AgentUpdateDataInput
  upsert: AgentUpsertNestedInput
  connect: AgentWhereUniqueInput
}

input AgentUpdateOneRequiredWithoutHostGamesInput {
  create: AgentCreateWithoutHostGamesInput
  update: AgentUpdateWithoutHostGamesDataInput
  upsert: AgentUpsertWithoutHostGamesInput
  connect: AgentWhereUniqueInput
}

input AgentUpdateOneWithoutGuestGamesInput {
  create: AgentCreateWithoutGuestGamesInput
  update: AgentUpdateWithoutGuestGamesDataInput
  upsert: AgentUpsertWithoutGuestGamesInput
  delete: Boolean
  disconnect: Boolean
  connect: AgentWhereUniqueInput
}

input AgentUpdateOneWithoutWinnedGamesInput {
  create: AgentCreateWithoutWinnedGamesInput
  update: AgentUpdateWithoutWinnedGamesDataInput
  upsert: AgentUpsertWithoutWinnedGamesInput
  delete: Boolean
  disconnect: Boolean
  connect: AgentWhereUniqueInput
}

input AgentUpdateWithoutGuestGamesDataInput {
  name: String
  script: String
  className: String
  hostGames: GameUpdateManyWithoutHostInput
  winnedGames: GameUpdateManyWithoutWinnerInput
}

input AgentUpdateWithoutHostGamesDataInput {
  name: String
  script: String
  className: String
  guestGames: GameUpdateManyWithoutGuestInput
  winnedGames: GameUpdateManyWithoutWinnerInput
}

input AgentUpdateWithoutWinnedGamesDataInput {
  name: String
  script: String
  className: String
  hostGames: GameUpdateManyWithoutHostInput
  guestGames: GameUpdateManyWithoutGuestInput
}

input AgentUpsertNestedInput {
  update: AgentUpdateDataInput!
  create: AgentCreateInput!
}

input AgentUpsertWithoutGuestGamesInput {
  update: AgentUpdateWithoutGuestGamesDataInput!
  create: AgentCreateWithoutGuestGamesInput!
}

input AgentUpsertWithoutHostGamesInput {
  update: AgentUpdateWithoutHostGamesDataInput!
  create: AgentCreateWithoutHostGamesInput!
}

input AgentUpsertWithoutWinnedGamesInput {
  update: AgentUpdateWithoutWinnedGamesDataInput!
  create: AgentCreateWithoutWinnedGamesInput!
}

input AgentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  script: String
  script_not: String
  script_in: [String!]
  script_not_in: [String!]
  script_lt: String
  script_lte: String
  script_gt: String
  script_gte: String
  script_contains: String
  script_not_contains: String
  script_starts_with: String
  script_not_starts_with: String
  script_ends_with: String
  script_not_ends_with: String
  className: String
  className_not: String
  className_in: [String!]
  className_not_in: [String!]
  className_lt: String
  className_lte: String
  className_gt: String
  className_gte: String
  className_contains: String
  className_not_contains: String
  className_starts_with: String
  className_not_starts_with: String
  className_ends_with: String
  className_not_ends_with: String
  hostGames_some: GameWhereInput
  guestGames_some: GameWhereInput
  winnedGames_some: GameWhereInput
  AND: [AgentWhereInput!]
}

input AgentWhereUniqueInput {
  id: ID
  name: String
}

type AggregateAgent {
  count: Int!
}

type AggregateGame {
  count: Int!
}

type AggregateGameMap {
  count: Int!
}

type AggregateMove {
  count: Int!
}

type AggregateWorkgroup {
  count: Int!
}

type AggregateWorkstation {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Game {
  id: ID!
  gameId: Int!
  createdAt: DateTime!
  host: Agent!
  guest: Agent
  playerOneId: ID
  playerTwoId: ID
  map: GameMap!
  status: GameStatus!
  state: GameState
  winner: Agent
  moves(where: MoveWhereInput, orderBy: MoveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Move!]
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]!
  aggregate: AggregateGame!
}

input GameCreateInput {
  id: ID
  gameId: Int!
  host: AgentCreateOneWithoutHostGamesInput!
  guest: AgentCreateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapCreateOneInput!
  status: GameStatus
  state: GameStateCreateOneInput
  winner: AgentCreateOneWithoutWinnedGamesInput
  moves: MoveCreateManyWithoutGameInput
}

input GameCreateManyWithoutGuestInput {
  create: [GameCreateWithoutGuestInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateManyWithoutHostInput {
  create: [GameCreateWithoutHostInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateManyWithoutWinnerInput {
  create: [GameCreateWithoutWinnerInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateOneWithoutMovesInput {
  create: GameCreateWithoutMovesInput
  connect: GameWhereUniqueInput
}

input GameCreateWithoutGuestInput {
  id: ID
  gameId: Int!
  host: AgentCreateOneWithoutHostGamesInput!
  playerOneId: ID
  playerTwoId: ID
  map: GameMapCreateOneInput!
  status: GameStatus
  state: GameStateCreateOneInput
  winner: AgentCreateOneWithoutWinnedGamesInput
  moves: MoveCreateManyWithoutGameInput
}

input GameCreateWithoutHostInput {
  id: ID
  gameId: Int!
  guest: AgentCreateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapCreateOneInput!
  status: GameStatus
  state: GameStateCreateOneInput
  winner: AgentCreateOneWithoutWinnedGamesInput
  moves: MoveCreateManyWithoutGameInput
}

input GameCreateWithoutMovesInput {
  id: ID
  gameId: Int!
  host: AgentCreateOneWithoutHostGamesInput!
  guest: AgentCreateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapCreateOneInput!
  status: GameStatus
  state: GameStateCreateOneInput
  winner: AgentCreateOneWithoutWinnedGamesInput
}

input GameCreateWithoutWinnerInput {
  id: ID
  gameId: Int!
  host: AgentCreateOneWithoutHostGamesInput!
  guest: AgentCreateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapCreateOneInput!
  status: GameStatus
  state: GameStateCreateOneInput
  moves: MoveCreateManyWithoutGameInput
}

type GameEdge {
  node: Game!
  cursor: String!
}

type GameMap {
  id: ID!
  name: String!
}

type GameMapConnection {
  pageInfo: PageInfo!
  edges: [GameMapEdge]!
  aggregate: AggregateGameMap!
}

input GameMapCreateInput {
  id: ID
  name: String!
}

input GameMapCreateOneInput {
  create: GameMapCreateInput
  connect: GameMapWhereUniqueInput
}

type GameMapEdge {
  node: GameMap!
  cursor: String!
}

enum GameMapOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type GameMapPreviousValues {
  id: ID!
  name: String!
}

type GameMapSubscriptionPayload {
  mutation: MutationType!
  node: GameMap
  updatedFields: [String!]
  previousValues: GameMapPreviousValues
}

input GameMapSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameMapWhereInput
  AND: [GameMapSubscriptionWhereInput!]
}

input GameMapUpdateDataInput {
  name: String
}

input GameMapUpdateInput {
  name: String
}

input GameMapUpdateManyMutationInput {
  name: String
}

input GameMapUpdateOneRequiredInput {
  create: GameMapCreateInput
  update: GameMapUpdateDataInput
  upsert: GameMapUpsertNestedInput
  connect: GameMapWhereUniqueInput
}

input GameMapUpsertNestedInput {
  update: GameMapUpdateDataInput!
  create: GameMapCreateInput!
}

input GameMapWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GameMapWhereInput!]
}

input GameMapWhereUniqueInput {
  id: ID
  name: String
}

enum GameOrderByInput {
  id_ASC
  id_DESC
  gameId_ASC
  gameId_DESC
  createdAt_ASC
  createdAt_DESC
  playerOneId_ASC
  playerOneId_DESC
  playerTwoId_ASC
  playerTwoId_DESC
  status_ASC
  status_DESC
}

type GamePreviousValues {
  id: ID!
  gameId: Int!
  createdAt: DateTime!
  playerOneId: ID
  playerTwoId: ID
  status: GameStatus!
}

input GameScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  gameId: Int
  gameId_not: Int
  gameId_in: [Int!]
  gameId_not_in: [Int!]
  gameId_lt: Int
  gameId_lte: Int
  gameId_gt: Int
  gameId_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  playerOneId: ID
  playerOneId_not: ID
  playerOneId_in: [ID!]
  playerOneId_not_in: [ID!]
  playerOneId_lt: ID
  playerOneId_lte: ID
  playerOneId_gt: ID
  playerOneId_gte: ID
  playerOneId_contains: ID
  playerOneId_not_contains: ID
  playerOneId_starts_with: ID
  playerOneId_not_starts_with: ID
  playerOneId_ends_with: ID
  playerOneId_not_ends_with: ID
  playerTwoId: ID
  playerTwoId_not: ID
  playerTwoId_in: [ID!]
  playerTwoId_not_in: [ID!]
  playerTwoId_lt: ID
  playerTwoId_lte: ID
  playerTwoId_gt: ID
  playerTwoId_gte: ID
  playerTwoId_contains: ID
  playerTwoId_not_contains: ID
  playerTwoId_starts_with: ID
  playerTwoId_not_starts_with: ID
  playerTwoId_ends_with: ID
  playerTwoId_not_ends_with: ID
  status: GameStatus
  status_not: GameStatus
  status_in: [GameStatus!]
  status_not_in: [GameStatus!]
  AND: [GameScalarWhereInput!]
  OR: [GameScalarWhereInput!]
  NOT: [GameScalarWhereInput!]
}

type GameState {
  playerTurn: ID!
  map: Map!
  player1: Player!
  player2: Player!
}

input GameStateCreateInput {
  playerTurn: ID!
  map: MapCreateOneInput!
  player1: PlayerCreateOneInput!
  player2: PlayerCreateOneInput!
}

input GameStateCreateOneInput {
  create: GameStateCreateInput
}

input GameStateUpdateDataInput {
  playerTurn: ID
  map: MapUpdateOneRequiredInput
  player1: PlayerUpdateOneRequiredInput
  player2: PlayerUpdateOneRequiredInput
}

input GameStateUpdateOneInput {
  create: GameStateCreateInput
  update: GameStateUpdateDataInput
  upsert: GameStateUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input GameStateUpdateOneRequiredInput {
  create: GameStateCreateInput
  update: GameStateUpdateDataInput
  upsert: GameStateUpsertNestedInput
}

input GameStateUpsertNestedInput {
  update: GameStateUpdateDataInput!
  create: GameStateCreateInput!
}

input GameStateWhereInput {
  playerTurn: ID
  playerTurn_not: ID
  playerTurn_in: [ID!]
  playerTurn_not_in: [ID!]
  playerTurn_lt: ID
  playerTurn_lte: ID
  playerTurn_gt: ID
  playerTurn_gte: ID
  playerTurn_contains: ID
  playerTurn_not_contains: ID
  playerTurn_starts_with: ID
  playerTurn_not_starts_with: ID
  playerTurn_ends_with: ID
  playerTurn_not_ends_with: ID
  map: MapWhereInput
  player1: PlayerWhereInput
  player2: PlayerWhereInput
  AND: [GameStateWhereInput!]
}

enum GameStatus {
  OPEN
  CLOSED
  READY
  IN_PLAY
  ENDED
}

type GameSubscriptionPayload {
  mutation: MutationType!
  node: Game
  updatedFields: [String!]
  previousValues: GamePreviousValues
}

input GameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameWhereInput
  AND: [GameSubscriptionWhereInput!]
}

input GameUpdateInput {
  gameId: Int
  host: AgentUpdateOneRequiredWithoutHostGamesInput
  guest: AgentUpdateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapUpdateOneRequiredInput
  status: GameStatus
  state: GameStateUpdateOneInput
  winner: AgentUpdateOneWithoutWinnedGamesInput
  moves: MoveUpdateManyWithoutGameInput
}

input GameUpdateManyDataInput {
  gameId: Int
  playerOneId: ID
  playerTwoId: ID
  status: GameStatus
}

input GameUpdateManyMutationInput {
  gameId: Int
  playerOneId: ID
  playerTwoId: ID
  status: GameStatus
}

input GameUpdateManyWithoutGuestInput {
  create: [GameCreateWithoutGuestInput!]
  delete: [GameWhereUniqueInput!]
  connect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutGuestInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutGuestInput!]
  deleteMany: [GameScalarWhereInput!]
  updateMany: [GameUpdateManyWithWhereNestedInput!]
}

input GameUpdateManyWithoutHostInput {
  create: [GameCreateWithoutHostInput!]
  delete: [GameWhereUniqueInput!]
  connect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutHostInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutHostInput!]
  deleteMany: [GameScalarWhereInput!]
  updateMany: [GameUpdateManyWithWhereNestedInput!]
}

input GameUpdateManyWithoutWinnerInput {
  create: [GameCreateWithoutWinnerInput!]
  delete: [GameWhereUniqueInput!]
  connect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutWinnerInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutWinnerInput!]
  deleteMany: [GameScalarWhereInput!]
  updateMany: [GameUpdateManyWithWhereNestedInput!]
}

input GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput!
  data: GameUpdateManyDataInput!
}

input GameUpdateOneRequiredWithoutMovesInput {
  create: GameCreateWithoutMovesInput
  update: GameUpdateWithoutMovesDataInput
  upsert: GameUpsertWithoutMovesInput
  connect: GameWhereUniqueInput
}

input GameUpdateWithoutGuestDataInput {
  gameId: Int
  host: AgentUpdateOneRequiredWithoutHostGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapUpdateOneRequiredInput
  status: GameStatus
  state: GameStateUpdateOneInput
  winner: AgentUpdateOneWithoutWinnedGamesInput
  moves: MoveUpdateManyWithoutGameInput
}

input GameUpdateWithoutHostDataInput {
  gameId: Int
  guest: AgentUpdateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapUpdateOneRequiredInput
  status: GameStatus
  state: GameStateUpdateOneInput
  winner: AgentUpdateOneWithoutWinnedGamesInput
  moves: MoveUpdateManyWithoutGameInput
}

input GameUpdateWithoutMovesDataInput {
  gameId: Int
  host: AgentUpdateOneRequiredWithoutHostGamesInput
  guest: AgentUpdateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapUpdateOneRequiredInput
  status: GameStatus
  state: GameStateUpdateOneInput
  winner: AgentUpdateOneWithoutWinnedGamesInput
}

input GameUpdateWithoutWinnerDataInput {
  gameId: Int
  host: AgentUpdateOneRequiredWithoutHostGamesInput
  guest: AgentUpdateOneWithoutGuestGamesInput
  playerOneId: ID
  playerTwoId: ID
  map: GameMapUpdateOneRequiredInput
  status: GameStatus
  state: GameStateUpdateOneInput
  moves: MoveUpdateManyWithoutGameInput
}

input GameUpdateWithWhereUniqueWithoutGuestInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutGuestDataInput!
}

input GameUpdateWithWhereUniqueWithoutHostInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutHostDataInput!
}

input GameUpdateWithWhereUniqueWithoutWinnerInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutWinnerDataInput!
}

input GameUpsertWithoutMovesInput {
  update: GameUpdateWithoutMovesDataInput!
  create: GameCreateWithoutMovesInput!
}

input GameUpsertWithWhereUniqueWithoutGuestInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutGuestDataInput!
  create: GameCreateWithoutGuestInput!
}

input GameUpsertWithWhereUniqueWithoutHostInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutHostDataInput!
  create: GameCreateWithoutHostInput!
}

input GameUpsertWithWhereUniqueWithoutWinnerInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutWinnerDataInput!
  create: GameCreateWithoutWinnerInput!
}

input GameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  gameId: Int
  gameId_not: Int
  gameId_in: [Int!]
  gameId_not_in: [Int!]
  gameId_lt: Int
  gameId_lte: Int
  gameId_gt: Int
  gameId_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  host: AgentWhereInput
  guest: AgentWhereInput
  playerOneId: ID
  playerOneId_not: ID
  playerOneId_in: [ID!]
  playerOneId_not_in: [ID!]
  playerOneId_lt: ID
  playerOneId_lte: ID
  playerOneId_gt: ID
  playerOneId_gte: ID
  playerOneId_contains: ID
  playerOneId_not_contains: ID
  playerOneId_starts_with: ID
  playerOneId_not_starts_with: ID
  playerOneId_ends_with: ID
  playerOneId_not_ends_with: ID
  playerTwoId: ID
  playerTwoId_not: ID
  playerTwoId_in: [ID!]
  playerTwoId_not_in: [ID!]
  playerTwoId_lt: ID
  playerTwoId_lte: ID
  playerTwoId_gt: ID
  playerTwoId_gte: ID
  playerTwoId_contains: ID
  playerTwoId_not_contains: ID
  playerTwoId_starts_with: ID
  playerTwoId_not_starts_with: ID
  playerTwoId_ends_with: ID
  playerTwoId_not_ends_with: ID
  map: GameMapWhereInput
  status: GameStatus
  status_not: GameStatus
  status_in: [GameStatus!]
  status_not_in: [GameStatus!]
  state: GameStateWhereInput
  winner: AgentWhereInput
  moves_some: MoveWhereInput
  AND: [GameWhereInput!]
}

input GameWhereUniqueInput {
  id: ID
}

enum ItemType {
  OBSTACLE
  FIRE
  WATER
  GRASS
}

scalar Long

type Map {
  tiles: [Tile!]
  width: Int!
  height: Int!
}

input MapCreateInput {
  tiles: TileCreateManyInput
  width: Int!
  height: Int!
}

input MapCreateOneInput {
  create: MapCreateInput
}

input MapUpdateDataInput {
  tiles: TileUpdateManyInput
  width: Int
  height: Int
}

input MapUpdateOneRequiredInput {
  create: MapCreateInput
  update: MapUpdateDataInput
  upsert: MapUpsertNestedInput
}

input MapUpsertNestedInput {
  update: MapUpdateDataInput!
  create: MapCreateInput!
}

input MapWhereInput {
  tiles_some: TileWhereInput
  tiles_every: TileRestrictedWhereInput
  tiles_none: TileRestrictedWhereInput
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  AND: [MapWhereInput!]
}

enum Morph {
  NEUTRAL
  FIRE
  WATER
  GRASS
}

type Move {
  id: ID!
  game: Game!
  player: Agent!
  action: Action
  actionType: ActionType
  state: GameState!
}

type MoveConnection {
  pageInfo: PageInfo!
  edges: [MoveEdge]!
  aggregate: AggregateMove!
}

input MoveCreateInput {
  id: ID
  game: GameCreateOneWithoutMovesInput!
  player: AgentCreateOneInput!
  action: Action
  actionType: ActionType
  state: GameStateCreateOneInput!
}

input MoveCreateManyWithoutGameInput {
  create: [MoveCreateWithoutGameInput!]
  connect: [MoveWhereUniqueInput!]
}

input MoveCreateWithoutGameInput {
  id: ID
  player: AgentCreateOneInput!
  action: Action
  actionType: ActionType
  state: GameStateCreateOneInput!
}

type MoveEdge {
  node: Move!
  cursor: String!
}

enum MoveOrderByInput {
  id_ASC
  id_DESC
  action_ASC
  action_DESC
  actionType_ASC
  actionType_DESC
}

type MovePreviousValues {
  id: ID!
  action: Action
  actionType: ActionType
}

input MoveScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  action: Action
  action_not: Action
  action_in: [Action!]
  action_not_in: [Action!]
  actionType: ActionType
  actionType_not: ActionType
  actionType_in: [ActionType!]
  actionType_not_in: [ActionType!]
  AND: [MoveScalarWhereInput!]
  OR: [MoveScalarWhereInput!]
  NOT: [MoveScalarWhereInput!]
}

type MoveSubscriptionPayload {
  mutation: MutationType!
  node: Move
  updatedFields: [String!]
  previousValues: MovePreviousValues
}

input MoveSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MoveWhereInput
  AND: [MoveSubscriptionWhereInput!]
}

input MoveUpdateInput {
  game: GameUpdateOneRequiredWithoutMovesInput
  player: AgentUpdateOneRequiredInput
  action: Action
  actionType: ActionType
  state: GameStateUpdateOneRequiredInput
}

input MoveUpdateManyDataInput {
  action: Action
  actionType: ActionType
}

input MoveUpdateManyMutationInput {
  action: Action
  actionType: ActionType
}

input MoveUpdateManyWithoutGameInput {
  create: [MoveCreateWithoutGameInput!]
  delete: [MoveWhereUniqueInput!]
  connect: [MoveWhereUniqueInput!]
  set: [MoveWhereUniqueInput!]
  disconnect: [MoveWhereUniqueInput!]
  update: [MoveUpdateWithWhereUniqueWithoutGameInput!]
  upsert: [MoveUpsertWithWhereUniqueWithoutGameInput!]
  deleteMany: [MoveScalarWhereInput!]
  updateMany: [MoveUpdateManyWithWhereNestedInput!]
}

input MoveUpdateManyWithWhereNestedInput {
  where: MoveScalarWhereInput!
  data: MoveUpdateManyDataInput!
}

input MoveUpdateWithoutGameDataInput {
  player: AgentUpdateOneRequiredInput
  action: Action
  actionType: ActionType
  state: GameStateUpdateOneRequiredInput
}

input MoveUpdateWithWhereUniqueWithoutGameInput {
  where: MoveWhereUniqueInput!
  data: MoveUpdateWithoutGameDataInput!
}

input MoveUpsertWithWhereUniqueWithoutGameInput {
  where: MoveWhereUniqueInput!
  update: MoveUpdateWithoutGameDataInput!
  create: MoveCreateWithoutGameInput!
}

input MoveWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  game: GameWhereInput
  player: AgentWhereInput
  action: Action
  action_not: Action
  action_in: [Action!]
  action_not_in: [Action!]
  actionType: ActionType
  actionType_not: ActionType
  actionType_in: [ActionType!]
  actionType_not_in: [ActionType!]
  state: GameStateWhereInput
  AND: [MoveWhereInput!]
}

input MoveWhereUniqueInput {
  id: ID
}

type Mutation {
  createAgent(data: AgentCreateInput!): Agent!
  updateAgent(data: AgentUpdateInput!, where: AgentWhereUniqueInput!): Agent
  updateManyAgents(data: AgentUpdateManyMutationInput!, where: AgentWhereInput): BatchPayload!
  upsertAgent(where: AgentWhereUniqueInput!, create: AgentCreateInput!, update: AgentUpdateInput!): Agent!
  deleteAgent(where: AgentWhereUniqueInput!): Agent
  deleteManyAgents(where: AgentWhereInput): BatchPayload!
  createGame(data: GameCreateInput!): Game!
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateManyGames(data: GameUpdateManyMutationInput!, where: GameWhereInput): BatchPayload!
  upsertGame(where: GameWhereUniqueInput!, create: GameCreateInput!, update: GameUpdateInput!): Game!
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteManyGames(where: GameWhereInput): BatchPayload!
  createGameMap(data: GameMapCreateInput!): GameMap!
  updateGameMap(data: GameMapUpdateInput!, where: GameMapWhereUniqueInput!): GameMap
  updateManyGameMaps(data: GameMapUpdateManyMutationInput!, where: GameMapWhereInput): BatchPayload!
  upsertGameMap(where: GameMapWhereUniqueInput!, create: GameMapCreateInput!, update: GameMapUpdateInput!): GameMap!
  deleteGameMap(where: GameMapWhereUniqueInput!): GameMap
  deleteManyGameMaps(where: GameMapWhereInput): BatchPayload!
  createMove(data: MoveCreateInput!): Move!
  updateMove(data: MoveUpdateInput!, where: MoveWhereUniqueInput!): Move
  updateManyMoves(data: MoveUpdateManyMutationInput!, where: MoveWhereInput): BatchPayload!
  upsertMove(where: MoveWhereUniqueInput!, create: MoveCreateInput!, update: MoveUpdateInput!): Move!
  deleteMove(where: MoveWhereUniqueInput!): Move
  deleteManyMoves(where: MoveWhereInput): BatchPayload!
  createWorkgroup(data: WorkgroupCreateInput!): Workgroup!
  updateWorkgroup(data: WorkgroupUpdateInput!, where: WorkgroupWhereUniqueInput!): Workgroup
  updateManyWorkgroups(data: WorkgroupUpdateManyMutationInput!, where: WorkgroupWhereInput): BatchPayload!
  upsertWorkgroup(where: WorkgroupWhereUniqueInput!, create: WorkgroupCreateInput!, update: WorkgroupUpdateInput!): Workgroup!
  deleteWorkgroup(where: WorkgroupWhereUniqueInput!): Workgroup
  deleteManyWorkgroups(where: WorkgroupWhereInput): BatchPayload!
  createWorkstation(data: WorkstationCreateInput!): Workstation!
  updateWorkstation(data: WorkstationUpdateInput!, where: WorkstationWhereUniqueInput!): Workstation
  updateManyWorkstations(data: WorkstationUpdateManyMutationInput!, where: WorkstationWhereInput): BatchPayload!
  upsertWorkstation(where: WorkstationWhereUniqueInput!, create: WorkstationCreateInput!, update: WorkstationUpdateInput!): Workstation!
  deleteWorkstation(where: WorkstationWhereUniqueInput!): Workstation
  deleteManyWorkstations(where: WorkstationWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  x: Int!
  y: Int!
  type: Morph!
  morphItems: [Morph!]!
  health: Int!
  lives: Int!
  lastAction: Action
}

input PlayerCreateInput {
  x: Int!
  y: Int!
  type: Morph!
  morphItems: PlayerCreatemorphItemsInput
  health: Int!
  lives: Int!
  lastAction: Action
}

input PlayerCreatemorphItemsInput {
  set: [Morph!]
}

input PlayerCreateOneInput {
  create: PlayerCreateInput
}

input PlayerUpdateDataInput {
  x: Int
  y: Int
  type: Morph
  morphItems: PlayerUpdatemorphItemsInput
  health: Int
  lives: Int
  lastAction: Action
}

input PlayerUpdatemorphItemsInput {
  set: [Morph!]
}

input PlayerUpdateOneRequiredInput {
  create: PlayerCreateInput
  update: PlayerUpdateDataInput
  upsert: PlayerUpsertNestedInput
}

input PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput!
  create: PlayerCreateInput!
}

input PlayerWhereInput {
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  type: Morph
  type_not: Morph
  type_in: [Morph!]
  type_not_in: [Morph!]
  health: Int
  health_not: Int
  health_in: [Int!]
  health_not_in: [Int!]
  health_lt: Int
  health_lte: Int
  health_gt: Int
  health_gte: Int
  lives: Int
  lives_not: Int
  lives_in: [Int!]
  lives_not_in: [Int!]
  lives_lt: Int
  lives_lte: Int
  lives_gt: Int
  lives_gte: Int
  lastAction: Action
  lastAction_not: Action
  lastAction_in: [Action!]
  lastAction_not_in: [Action!]
  AND: [PlayerWhereInput!]
}

type Query {
  agent(where: AgentWhereUniqueInput!): Agent
  agents(where: AgentWhereInput, orderBy: AgentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Agent]!
  agentsConnection(where: AgentWhereInput, orderBy: AgentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AgentConnection!
  game(where: GameWhereUniqueInput!): Game
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game]!
  gamesConnection(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameConnection!
  gameMap(where: GameMapWhereUniqueInput!): GameMap
  gameMaps(where: GameMapWhereInput, orderBy: GameMapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GameMap]!
  gameMapsConnection(where: GameMapWhereInput, orderBy: GameMapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameMapConnection!
  move(where: MoveWhereUniqueInput!): Move
  moves(where: MoveWhereInput, orderBy: MoveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Move]!
  movesConnection(where: MoveWhereInput, orderBy: MoveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MoveConnection!
  workgroup(where: WorkgroupWhereUniqueInput!): Workgroup
  workgroups(where: WorkgroupWhereInput, orderBy: WorkgroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workgroup]!
  workgroupsConnection(where: WorkgroupWhereInput, orderBy: WorkgroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkgroupConnection!
  workstation(where: WorkstationWhereUniqueInput!): Workstation
  workstations(where: WorkstationWhereInput, orderBy: WorkstationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workstation]!
  workstationsConnection(where: WorkstationWhereInput, orderBy: WorkstationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkstationConnection!
  node(id: ID!): Node
}

type Subscription {
  agent(where: AgentSubscriptionWhereInput): AgentSubscriptionPayload
  game(where: GameSubscriptionWhereInput): GameSubscriptionPayload
  gameMap(where: GameMapSubscriptionWhereInput): GameMapSubscriptionPayload
  move(where: MoveSubscriptionWhereInput): MoveSubscriptionPayload
  workgroup(where: WorkgroupSubscriptionWhereInput): WorkgroupSubscriptionPayload
  workstation(where: WorkstationSubscriptionWhereInput): WorkstationSubscriptionPayload
}

type Tile {
  type: TileType!
  item: ItemType
}

input TileCreateInput {
  type: TileType!
  item: ItemType
}

input TileCreateManyInput {
  create: [TileCreateInput!]
}

input TileRestrictedWhereInput {
  type: TileType
  type_not: TileType
  type_in: [TileType!]
  type_not_in: [TileType!]
  item: ItemType
  item_not: ItemType
  item_in: [ItemType!]
  item_not_in: [ItemType!]
  AND: [TileRestrictedWhereInput!]
}

input TileScalarWhereInput {
  type: TileType
  type_not: TileType
  type_in: [TileType!]
  type_not_in: [TileType!]
  item: ItemType
  item_not: ItemType
  item_in: [ItemType!]
  item_not_in: [ItemType!]
  AND: [TileScalarWhereInput!]
  OR: [TileScalarWhereInput!]
  NOT: [TileScalarWhereInput!]
}

enum TileType {
  NORMAL
  FIRE
  WATER
  GRASS
}

input TileUpdateManyDataInput {
  type: TileType
  item: ItemType
}

input TileUpdateManyInput {
  create: [TileCreateInput!]
  deleteMany: [TileScalarWhereInput!]
  updateMany: [TileUpdateManyWithWhereNestedInput!]
}

input TileUpdateManyWithWhereNestedInput {
  where: TileScalarWhereInput!
  data: TileUpdateManyDataInput!
}

input TileWhereInput {
  type: TileType
  type_not: TileType
  type_in: [TileType!]
  type_not_in: [TileType!]
  item: ItemType
  item_not: ItemType
  item_in: [ItemType!]
  item_not_in: [ItemType!]
  AND: [TileWhereInput!]
}

type Workgroup {
  id: ID!
  workstation: Workstation!
  busy: Boolean!
}

type WorkgroupConnection {
  pageInfo: PageInfo!
  edges: [WorkgroupEdge]!
  aggregate: AggregateWorkgroup!
}

input WorkgroupCreateInput {
  id: ID
  workstation: WorkstationCreateOneWithoutWorkgroupsInput!
  busy: Boolean
}

input WorkgroupCreateManyWithoutWorkstationInput {
  create: [WorkgroupCreateWithoutWorkstationInput!]
  connect: [WorkgroupWhereUniqueInput!]
}

input WorkgroupCreateWithoutWorkstationInput {
  id: ID
  busy: Boolean
}

type WorkgroupEdge {
  node: Workgroup!
  cursor: String!
}

enum WorkgroupOrderByInput {
  id_ASC
  id_DESC
  busy_ASC
  busy_DESC
}

type WorkgroupPreviousValues {
  id: ID!
  busy: Boolean!
}

input WorkgroupScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  busy: Boolean
  busy_not: Boolean
  AND: [WorkgroupScalarWhereInput!]
  OR: [WorkgroupScalarWhereInput!]
  NOT: [WorkgroupScalarWhereInput!]
}

type WorkgroupSubscriptionPayload {
  mutation: MutationType!
  node: Workgroup
  updatedFields: [String!]
  previousValues: WorkgroupPreviousValues
}

input WorkgroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkgroupWhereInput
  AND: [WorkgroupSubscriptionWhereInput!]
}

input WorkgroupUpdateInput {
  workstation: WorkstationUpdateOneRequiredWithoutWorkgroupsInput
  busy: Boolean
}

input WorkgroupUpdateManyDataInput {
  busy: Boolean
}

input WorkgroupUpdateManyMutationInput {
  busy: Boolean
}

input WorkgroupUpdateManyWithoutWorkstationInput {
  create: [WorkgroupCreateWithoutWorkstationInput!]
  delete: [WorkgroupWhereUniqueInput!]
  connect: [WorkgroupWhereUniqueInput!]
  set: [WorkgroupWhereUniqueInput!]
  disconnect: [WorkgroupWhereUniqueInput!]
  update: [WorkgroupUpdateWithWhereUniqueWithoutWorkstationInput!]
  upsert: [WorkgroupUpsertWithWhereUniqueWithoutWorkstationInput!]
  deleteMany: [WorkgroupScalarWhereInput!]
  updateMany: [WorkgroupUpdateManyWithWhereNestedInput!]
}

input WorkgroupUpdateManyWithWhereNestedInput {
  where: WorkgroupScalarWhereInput!
  data: WorkgroupUpdateManyDataInput!
}

input WorkgroupUpdateWithoutWorkstationDataInput {
  busy: Boolean
}

input WorkgroupUpdateWithWhereUniqueWithoutWorkstationInput {
  where: WorkgroupWhereUniqueInput!
  data: WorkgroupUpdateWithoutWorkstationDataInput!
}

input WorkgroupUpsertWithWhereUniqueWithoutWorkstationInput {
  where: WorkgroupWhereUniqueInput!
  update: WorkgroupUpdateWithoutWorkstationDataInput!
  create: WorkgroupCreateWithoutWorkstationInput!
}

input WorkgroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workstation: WorkstationWhereInput
  busy: Boolean
  busy_not: Boolean
  AND: [WorkgroupWhereInput!]
}

input WorkgroupWhereUniqueInput {
  id: ID
}

type Workstation {
  id: ID!
  name: String!
  url: String!
  privateKey: String!
  workgroups(where: WorkgroupWhereInput, orderBy: WorkgroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workgroup!]
}

type WorkstationConnection {
  pageInfo: PageInfo!
  edges: [WorkstationEdge]!
  aggregate: AggregateWorkstation!
}

input WorkstationCreateInput {
  id: ID
  name: String!
  url: String!
  privateKey: String!
  workgroups: WorkgroupCreateManyWithoutWorkstationInput
}

input WorkstationCreateOneWithoutWorkgroupsInput {
  create: WorkstationCreateWithoutWorkgroupsInput
  connect: WorkstationWhereUniqueInput
}

input WorkstationCreateWithoutWorkgroupsInput {
  id: ID
  name: String!
  url: String!
  privateKey: String!
}

type WorkstationEdge {
  node: Workstation!
  cursor: String!
}

enum WorkstationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  url_ASC
  url_DESC
  privateKey_ASC
  privateKey_DESC
}

type WorkstationPreviousValues {
  id: ID!
  name: String!
  url: String!
  privateKey: String!
}

type WorkstationSubscriptionPayload {
  mutation: MutationType!
  node: Workstation
  updatedFields: [String!]
  previousValues: WorkstationPreviousValues
}

input WorkstationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkstationWhereInput
  AND: [WorkstationSubscriptionWhereInput!]
}

input WorkstationUpdateInput {
  name: String
  url: String
  privateKey: String
  workgroups: WorkgroupUpdateManyWithoutWorkstationInput
}

input WorkstationUpdateManyMutationInput {
  name: String
  url: String
  privateKey: String
}

input WorkstationUpdateOneRequiredWithoutWorkgroupsInput {
  create: WorkstationCreateWithoutWorkgroupsInput
  update: WorkstationUpdateWithoutWorkgroupsDataInput
  upsert: WorkstationUpsertWithoutWorkgroupsInput
  connect: WorkstationWhereUniqueInput
}

input WorkstationUpdateWithoutWorkgroupsDataInput {
  name: String
  url: String
  privateKey: String
}

input WorkstationUpsertWithoutWorkgroupsInput {
  update: WorkstationUpdateWithoutWorkgroupsDataInput!
  create: WorkstationCreateWithoutWorkgroupsInput!
}

input WorkstationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  privateKey: String
  privateKey_not: String
  privateKey_in: [String!]
  privateKey_not_in: [String!]
  privateKey_lt: String
  privateKey_lte: String
  privateKey_gt: String
  privateKey_gte: String
  privateKey_contains: String
  privateKey_not_contains: String
  privateKey_starts_with: String
  privateKey_not_starts_with: String
  privateKey_ends_with: String
  privateKey_not_ends_with: String
  workgroups_some: WorkgroupWhereInput
  AND: [WorkstationWhereInput!]
}

input WorkstationWhereUniqueInput {
  id: ID
  name: String
  url: String
}
`
      }
    