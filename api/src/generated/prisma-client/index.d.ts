// Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  agent: (where?: AgentWhereInput) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  gameMap: (where?: GameMapWhereInput) => Promise<boolean>;
  move: (where?: MoveWhereInput) => Promise<boolean>;
  workgroup: (where?: WorkgroupWhereInput) => Promise<boolean>;
  workstation: (where?: WorkstationWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  agent: (where: AgentWhereUniqueInput) => AgentNullablePromise;
  agents: (args?: {
    where?: AgentWhereInput;
    orderBy?: AgentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Agent>;
  agentsConnection: (args?: {
    where?: AgentWhereInput;
    orderBy?: AgentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AgentConnectionPromise;
  game: (where: GameWhereUniqueInput) => GameNullablePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  gameMap: (where: GameMapWhereUniqueInput) => GameMapNullablePromise;
  gameMaps: (args?: {
    where?: GameMapWhereInput;
    orderBy?: GameMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GameMap>;
  gameMapsConnection: (args?: {
    where?: GameMapWhereInput;
    orderBy?: GameMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameMapConnectionPromise;
  move: (where: MoveWhereUniqueInput) => MoveNullablePromise;
  moves: (args?: {
    where?: MoveWhereInput;
    orderBy?: MoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Move>;
  movesConnection: (args?: {
    where?: MoveWhereInput;
    orderBy?: MoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MoveConnectionPromise;
  workgroup: (where: WorkgroupWhereUniqueInput) => WorkgroupNullablePromise;
  workgroups: (args?: {
    where?: WorkgroupWhereInput;
    orderBy?: WorkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Workgroup>;
  workgroupsConnection: (args?: {
    where?: WorkgroupWhereInput;
    orderBy?: WorkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkgroupConnectionPromise;
  workstation: (
    where: WorkstationWhereUniqueInput
  ) => WorkstationNullablePromise;
  workstations: (args?: {
    where?: WorkstationWhereInput;
    orderBy?: WorkstationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Workstation>;
  workstationsConnection: (args?: {
    where?: WorkstationWhereInput;
    orderBy?: WorkstationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkstationConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAgent: (data: AgentCreateInput) => AgentPromise;
  updateAgent: (args: {
    data: AgentUpdateInput;
    where: AgentWhereUniqueInput;
  }) => AgentPromise;
  updateManyAgents: (args: {
    data: AgentUpdateManyMutationInput;
    where?: AgentWhereInput;
  }) => BatchPayloadPromise;
  upsertAgent: (args: {
    where: AgentWhereUniqueInput;
    create: AgentCreateInput;
    update: AgentUpdateInput;
  }) => AgentPromise;
  deleteAgent: (where: AgentWhereUniqueInput) => AgentPromise;
  deleteManyAgents: (where?: AgentWhereInput) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createGameMap: (data: GameMapCreateInput) => GameMapPromise;
  updateGameMap: (args: {
    data: GameMapUpdateInput;
    where: GameMapWhereUniqueInput;
  }) => GameMapPromise;
  updateManyGameMaps: (args: {
    data: GameMapUpdateManyMutationInput;
    where?: GameMapWhereInput;
  }) => BatchPayloadPromise;
  upsertGameMap: (args: {
    where: GameMapWhereUniqueInput;
    create: GameMapCreateInput;
    update: GameMapUpdateInput;
  }) => GameMapPromise;
  deleteGameMap: (where: GameMapWhereUniqueInput) => GameMapPromise;
  deleteManyGameMaps: (where?: GameMapWhereInput) => BatchPayloadPromise;
  createMove: (data: MoveCreateInput) => MovePromise;
  updateMove: (args: {
    data: MoveUpdateInput;
    where: MoveWhereUniqueInput;
  }) => MovePromise;
  updateManyMoves: (args: {
    data: MoveUpdateManyMutationInput;
    where?: MoveWhereInput;
  }) => BatchPayloadPromise;
  upsertMove: (args: {
    where: MoveWhereUniqueInput;
    create: MoveCreateInput;
    update: MoveUpdateInput;
  }) => MovePromise;
  deleteMove: (where: MoveWhereUniqueInput) => MovePromise;
  deleteManyMoves: (where?: MoveWhereInput) => BatchPayloadPromise;
  createWorkgroup: (data: WorkgroupCreateInput) => WorkgroupPromise;
  updateWorkgroup: (args: {
    data: WorkgroupUpdateInput;
    where: WorkgroupWhereUniqueInput;
  }) => WorkgroupPromise;
  updateManyWorkgroups: (args: {
    data: WorkgroupUpdateManyMutationInput;
    where?: WorkgroupWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkgroup: (args: {
    where: WorkgroupWhereUniqueInput;
    create: WorkgroupCreateInput;
    update: WorkgroupUpdateInput;
  }) => WorkgroupPromise;
  deleteWorkgroup: (where: WorkgroupWhereUniqueInput) => WorkgroupPromise;
  deleteManyWorkgroups: (where?: WorkgroupWhereInput) => BatchPayloadPromise;
  createWorkstation: (data: WorkstationCreateInput) => WorkstationPromise;
  updateWorkstation: (args: {
    data: WorkstationUpdateInput;
    where: WorkstationWhereUniqueInput;
  }) => WorkstationPromise;
  updateManyWorkstations: (args: {
    data: WorkstationUpdateManyMutationInput;
    where?: WorkstationWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkstation: (args: {
    where: WorkstationWhereUniqueInput;
    create: WorkstationCreateInput;
    update: WorkstationUpdateInput;
  }) => WorkstationPromise;
  deleteWorkstation: (where: WorkstationWhereUniqueInput) => WorkstationPromise;
  deleteManyWorkstations: (
    where?: WorkstationWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  agent: (
    where?: AgentSubscriptionWhereInput
  ) => AgentSubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  gameMap: (
    where?: GameMapSubscriptionWhereInput
  ) => GameMapSubscriptionPayloadSubscription;
  move: (
    where?: MoveSubscriptionWhereInput
  ) => MoveSubscriptionPayloadSubscription;
  workgroup: (
    where?: WorkgroupSubscriptionWhereInput
  ) => WorkgroupSubscriptionPayloadSubscription;
  workstation: (
    where?: WorkstationSubscriptionWhereInput
  ) => WorkstationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type GameStatus = "OPEN" | "CLOSED" | "READY" | "IN_PLAY" | "ENDED";

export type TileType = "NORMAL" | "FIRE" | "WATER" | "GRASS";

export type ItemType = "OBSTACLE" | "FIRE" | "WATER" | "GRASS";

export type Morph = "NEUTRAL" | "FIRE" | "WATER" | "GRASS";

export type Action =
  | "MOVE_UP"
  | "MOVE_LEFT"
  | "MOVE_DOWN"
  | "MOVE_RIGHT"
  | "ATTACK_UP"
  | "ATTACK_LEFT"
  | "ATTACK_DOWN"
  | "ATTACK_RIGHT"
  | "TRANSFORM_NORMAL"
  | "TRANSFORM_FIRE"
  | "TRANSFORM_WATER"
  | "TRANSFORM_GRASS";

export type ActionType =
  | "MOVE"
  | "COLLECT"
  | "TRANSFORM"
  | "ATTACK"
  | "RESTORE_HP"
  | "WAIT";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "gameId_ASC"
  | "gameId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "playerOneId_ASC"
  | "playerOneId_DESC"
  | "playerTwoId_ASC"
  | "playerTwoId_DESC"
  | "status_ASC"
  | "status_DESC";

export type MoveOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "action_ASC"
  | "action_DESC"
  | "actionType_ASC"
  | "actionType_DESC";

export type AgentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "script_ASC"
  | "script_DESC"
  | "className_ASC"
  | "className_DESC";

export type GameMapOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type WorkgroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "busy_ASC"
  | "busy_DESC";

export type WorkstationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "url_ASC"
  | "url_DESC"
  | "privateKey_ASC"
  | "privateKey_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AgentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface GameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  gameId?: Maybe<Int>;
  gameId_not?: Maybe<Int>;
  gameId_in?: Maybe<Int[] | Int>;
  gameId_not_in?: Maybe<Int[] | Int>;
  gameId_lt?: Maybe<Int>;
  gameId_lte?: Maybe<Int>;
  gameId_gt?: Maybe<Int>;
  gameId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  host?: Maybe<AgentWhereInput>;
  guest?: Maybe<AgentWhereInput>;
  playerOneId?: Maybe<ID_Input>;
  playerOneId_not?: Maybe<ID_Input>;
  playerOneId_in?: Maybe<ID_Input[] | ID_Input>;
  playerOneId_not_in?: Maybe<ID_Input[] | ID_Input>;
  playerOneId_lt?: Maybe<ID_Input>;
  playerOneId_lte?: Maybe<ID_Input>;
  playerOneId_gt?: Maybe<ID_Input>;
  playerOneId_gte?: Maybe<ID_Input>;
  playerOneId_contains?: Maybe<ID_Input>;
  playerOneId_not_contains?: Maybe<ID_Input>;
  playerOneId_starts_with?: Maybe<ID_Input>;
  playerOneId_not_starts_with?: Maybe<ID_Input>;
  playerOneId_ends_with?: Maybe<ID_Input>;
  playerOneId_not_ends_with?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  playerTwoId_not?: Maybe<ID_Input>;
  playerTwoId_in?: Maybe<ID_Input[] | ID_Input>;
  playerTwoId_not_in?: Maybe<ID_Input[] | ID_Input>;
  playerTwoId_lt?: Maybe<ID_Input>;
  playerTwoId_lte?: Maybe<ID_Input>;
  playerTwoId_gt?: Maybe<ID_Input>;
  playerTwoId_gte?: Maybe<ID_Input>;
  playerTwoId_contains?: Maybe<ID_Input>;
  playerTwoId_not_contains?: Maybe<ID_Input>;
  playerTwoId_starts_with?: Maybe<ID_Input>;
  playerTwoId_not_starts_with?: Maybe<ID_Input>;
  playerTwoId_ends_with?: Maybe<ID_Input>;
  playerTwoId_not_ends_with?: Maybe<ID_Input>;
  map?: Maybe<GameMapWhereInput>;
  status?: Maybe<GameStatus>;
  status_not?: Maybe<GameStatus>;
  status_in?: Maybe<GameStatus[] | GameStatus>;
  status_not_in?: Maybe<GameStatus[] | GameStatus>;
  state?: Maybe<GameStateWhereInput>;
  winner?: Maybe<AgentWhereInput>;
  moves_some?: Maybe<MoveWhereInput>;
  AND?: Maybe<GameWhereInput[] | GameWhereInput>;
}

export interface AgentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  script?: Maybe<String>;
  script_not?: Maybe<String>;
  script_in?: Maybe<String[] | String>;
  script_not_in?: Maybe<String[] | String>;
  script_lt?: Maybe<String>;
  script_lte?: Maybe<String>;
  script_gt?: Maybe<String>;
  script_gte?: Maybe<String>;
  script_contains?: Maybe<String>;
  script_not_contains?: Maybe<String>;
  script_starts_with?: Maybe<String>;
  script_not_starts_with?: Maybe<String>;
  script_ends_with?: Maybe<String>;
  script_not_ends_with?: Maybe<String>;
  className?: Maybe<String>;
  className_not?: Maybe<String>;
  className_in?: Maybe<String[] | String>;
  className_not_in?: Maybe<String[] | String>;
  className_lt?: Maybe<String>;
  className_lte?: Maybe<String>;
  className_gt?: Maybe<String>;
  className_gte?: Maybe<String>;
  className_contains?: Maybe<String>;
  className_not_contains?: Maybe<String>;
  className_starts_with?: Maybe<String>;
  className_not_starts_with?: Maybe<String>;
  className_ends_with?: Maybe<String>;
  className_not_ends_with?: Maybe<String>;
  hostGames_some?: Maybe<GameWhereInput>;
  guestGames_some?: Maybe<GameWhereInput>;
  winnedGames_some?: Maybe<GameWhereInput>;
  AND?: Maybe<AgentWhereInput[] | AgentWhereInput>;
}

export interface GameMapWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<GameMapWhereInput[] | GameMapWhereInput>;
}

export interface GameStateWhereInput {
  playerTurn?: Maybe<ID_Input>;
  playerTurn_not?: Maybe<ID_Input>;
  playerTurn_in?: Maybe<ID_Input[] | ID_Input>;
  playerTurn_not_in?: Maybe<ID_Input[] | ID_Input>;
  playerTurn_lt?: Maybe<ID_Input>;
  playerTurn_lte?: Maybe<ID_Input>;
  playerTurn_gt?: Maybe<ID_Input>;
  playerTurn_gte?: Maybe<ID_Input>;
  playerTurn_contains?: Maybe<ID_Input>;
  playerTurn_not_contains?: Maybe<ID_Input>;
  playerTurn_starts_with?: Maybe<ID_Input>;
  playerTurn_not_starts_with?: Maybe<ID_Input>;
  playerTurn_ends_with?: Maybe<ID_Input>;
  playerTurn_not_ends_with?: Maybe<ID_Input>;
  map?: Maybe<MapWhereInput>;
  player1?: Maybe<PlayerWhereInput>;
  player2?: Maybe<PlayerWhereInput>;
  AND?: Maybe<GameStateWhereInput[] | GameStateWhereInput>;
}

export interface MapWhereInput {
  tiles_some?: Maybe<TileWhereInput>;
  tiles_every?: Maybe<TileRestrictedWhereInput>;
  tiles_none?: Maybe<TileRestrictedWhereInput>;
  width?: Maybe<Int>;
  width_not?: Maybe<Int>;
  width_in?: Maybe<Int[] | Int>;
  width_not_in?: Maybe<Int[] | Int>;
  width_lt?: Maybe<Int>;
  width_lte?: Maybe<Int>;
  width_gt?: Maybe<Int>;
  width_gte?: Maybe<Int>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  AND?: Maybe<MapWhereInput[] | MapWhereInput>;
}

export interface TileWhereInput {
  type?: Maybe<TileType>;
  type_not?: Maybe<TileType>;
  type_in?: Maybe<TileType[] | TileType>;
  type_not_in?: Maybe<TileType[] | TileType>;
  item?: Maybe<ItemType>;
  item_not?: Maybe<ItemType>;
  item_in?: Maybe<ItemType[] | ItemType>;
  item_not_in?: Maybe<ItemType[] | ItemType>;
  AND?: Maybe<TileWhereInput[] | TileWhereInput>;
}

export interface TileRestrictedWhereInput {
  type?: Maybe<TileType>;
  type_not?: Maybe<TileType>;
  type_in?: Maybe<TileType[] | TileType>;
  type_not_in?: Maybe<TileType[] | TileType>;
  item?: Maybe<ItemType>;
  item_not?: Maybe<ItemType>;
  item_in?: Maybe<ItemType[] | ItemType>;
  item_not_in?: Maybe<ItemType[] | ItemType>;
  AND?: Maybe<TileRestrictedWhereInput[] | TileRestrictedWhereInput>;
}

export interface PlayerWhereInput {
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  type?: Maybe<Morph>;
  type_not?: Maybe<Morph>;
  type_in?: Maybe<Morph[] | Morph>;
  type_not_in?: Maybe<Morph[] | Morph>;
  health?: Maybe<Int>;
  health_not?: Maybe<Int>;
  health_in?: Maybe<Int[] | Int>;
  health_not_in?: Maybe<Int[] | Int>;
  health_lt?: Maybe<Int>;
  health_lte?: Maybe<Int>;
  health_gt?: Maybe<Int>;
  health_gte?: Maybe<Int>;
  lives?: Maybe<Int>;
  lives_not?: Maybe<Int>;
  lives_in?: Maybe<Int[] | Int>;
  lives_not_in?: Maybe<Int[] | Int>;
  lives_lt?: Maybe<Int>;
  lives_lte?: Maybe<Int>;
  lives_gt?: Maybe<Int>;
  lives_gte?: Maybe<Int>;
  lastAction?: Maybe<Action>;
  lastAction_not?: Maybe<Action>;
  lastAction_in?: Maybe<Action[] | Action>;
  lastAction_not_in?: Maybe<Action[] | Action>;
  AND?: Maybe<PlayerWhereInput[] | PlayerWhereInput>;
}

export interface MoveWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  game?: Maybe<GameWhereInput>;
  player?: Maybe<AgentWhereInput>;
  action?: Maybe<Action>;
  action_not?: Maybe<Action>;
  action_in?: Maybe<Action[] | Action>;
  action_not_in?: Maybe<Action[] | Action>;
  actionType?: Maybe<ActionType>;
  actionType_not?: Maybe<ActionType>;
  actionType_in?: Maybe<ActionType[] | ActionType>;
  actionType_not_in?: Maybe<ActionType[] | ActionType>;
  state?: Maybe<GameStateWhereInput>;
  AND?: Maybe<MoveWhereInput[] | MoveWhereInput>;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GameMapWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type MoveWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WorkgroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WorkgroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  workstation?: Maybe<WorkstationWhereInput>;
  busy?: Maybe<Boolean>;
  busy_not?: Maybe<Boolean>;
  AND?: Maybe<WorkgroupWhereInput[] | WorkgroupWhereInput>;
}

export interface WorkstationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  privateKey?: Maybe<String>;
  privateKey_not?: Maybe<String>;
  privateKey_in?: Maybe<String[] | String>;
  privateKey_not_in?: Maybe<String[] | String>;
  privateKey_lt?: Maybe<String>;
  privateKey_lte?: Maybe<String>;
  privateKey_gt?: Maybe<String>;
  privateKey_gte?: Maybe<String>;
  privateKey_contains?: Maybe<String>;
  privateKey_not_contains?: Maybe<String>;
  privateKey_starts_with?: Maybe<String>;
  privateKey_not_starts_with?: Maybe<String>;
  privateKey_ends_with?: Maybe<String>;
  privateKey_not_ends_with?: Maybe<String>;
  workgroups_some?: Maybe<WorkgroupWhereInput>;
  AND?: Maybe<WorkstationWhereInput[] | WorkstationWhereInput>;
}

export type WorkstationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  url?: Maybe<String>;
}>;

export interface AgentCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  script?: Maybe<String>;
  className?: Maybe<String>;
  hostGames?: Maybe<GameCreateManyWithoutHostInput>;
  guestGames?: Maybe<GameCreateManyWithoutGuestInput>;
  winnedGames?: Maybe<GameCreateManyWithoutWinnerInput>;
}

export interface GameCreateManyWithoutHostInput {
  create?: Maybe<GameCreateWithoutHostInput[] | GameCreateWithoutHostInput>;
  connect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
}

export interface GameCreateWithoutHostInput {
  id?: Maybe<ID_Input>;
  gameId: Int;
  guest?: Maybe<AgentCreateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map: GameMapCreateOneInput;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateCreateOneInput>;
  winner?: Maybe<AgentCreateOneWithoutWinnedGamesInput>;
  moves?: Maybe<MoveCreateManyWithoutGameInput>;
}

export interface AgentCreateOneWithoutGuestGamesInput {
  create?: Maybe<AgentCreateWithoutGuestGamesInput>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentCreateWithoutGuestGamesInput {
  id?: Maybe<ID_Input>;
  name: String;
  script?: Maybe<String>;
  className?: Maybe<String>;
  hostGames?: Maybe<GameCreateManyWithoutHostInput>;
  winnedGames?: Maybe<GameCreateManyWithoutWinnerInput>;
}

export interface GameCreateManyWithoutWinnerInput {
  create?: Maybe<GameCreateWithoutWinnerInput[] | GameCreateWithoutWinnerInput>;
  connect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
}

export interface GameCreateWithoutWinnerInput {
  id?: Maybe<ID_Input>;
  gameId: Int;
  host: AgentCreateOneWithoutHostGamesInput;
  guest?: Maybe<AgentCreateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map: GameMapCreateOneInput;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateCreateOneInput>;
  moves?: Maybe<MoveCreateManyWithoutGameInput>;
}

export interface AgentCreateOneWithoutHostGamesInput {
  create?: Maybe<AgentCreateWithoutHostGamesInput>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentCreateWithoutHostGamesInput {
  id?: Maybe<ID_Input>;
  name: String;
  script?: Maybe<String>;
  className?: Maybe<String>;
  guestGames?: Maybe<GameCreateManyWithoutGuestInput>;
  winnedGames?: Maybe<GameCreateManyWithoutWinnerInput>;
}

export interface GameCreateManyWithoutGuestInput {
  create?: Maybe<GameCreateWithoutGuestInput[] | GameCreateWithoutGuestInput>;
  connect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
}

export interface GameCreateWithoutGuestInput {
  id?: Maybe<ID_Input>;
  gameId: Int;
  host: AgentCreateOneWithoutHostGamesInput;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map: GameMapCreateOneInput;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateCreateOneInput>;
  winner?: Maybe<AgentCreateOneWithoutWinnedGamesInput>;
  moves?: Maybe<MoveCreateManyWithoutGameInput>;
}

export interface GameMapCreateOneInput {
  create?: Maybe<GameMapCreateInput>;
  connect?: Maybe<GameMapWhereUniqueInput>;
}

export interface GameMapCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface GameStateCreateOneInput {
  create?: Maybe<GameStateCreateInput>;
}

export interface GameStateCreateInput {
  playerTurn: ID_Input;
  map: MapCreateOneInput;
  player1: PlayerCreateOneInput;
  player2: PlayerCreateOneInput;
}

export interface MapCreateOneInput {
  create?: Maybe<MapCreateInput>;
}

export interface MapCreateInput {
  tiles?: Maybe<TileCreateManyInput>;
  width: Int;
  height: Int;
}

export interface TileCreateManyInput {
  create?: Maybe<TileCreateInput[] | TileCreateInput>;
}

export interface TileCreateInput {
  type: TileType;
  item?: Maybe<ItemType>;
}

export interface PlayerCreateOneInput {
  create?: Maybe<PlayerCreateInput>;
}

export interface PlayerCreateInput {
  x: Int;
  y: Int;
  type: Morph;
  morphItems?: Maybe<PlayerCreatemorphItemsInput>;
  health: Int;
  lives: Int;
  lastAction?: Maybe<Action>;
}

export interface PlayerCreatemorphItemsInput {
  set?: Maybe<Morph[] | Morph>;
}

export interface AgentCreateOneWithoutWinnedGamesInput {
  create?: Maybe<AgentCreateWithoutWinnedGamesInput>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentCreateWithoutWinnedGamesInput {
  id?: Maybe<ID_Input>;
  name: String;
  script?: Maybe<String>;
  className?: Maybe<String>;
  hostGames?: Maybe<GameCreateManyWithoutHostInput>;
  guestGames?: Maybe<GameCreateManyWithoutGuestInput>;
}

export interface MoveCreateManyWithoutGameInput {
  create?: Maybe<MoveCreateWithoutGameInput[] | MoveCreateWithoutGameInput>;
  connect?: Maybe<MoveWhereUniqueInput[] | MoveWhereUniqueInput>;
}

export interface MoveCreateWithoutGameInput {
  id?: Maybe<ID_Input>;
  player: AgentCreateOneInput;
  action?: Maybe<Action>;
  actionType?: Maybe<ActionType>;
  state: GameStateCreateOneInput;
}

export interface AgentCreateOneInput {
  create?: Maybe<AgentCreateInput>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentUpdateInput {
  name?: Maybe<String>;
  script?: Maybe<String>;
  className?: Maybe<String>;
  hostGames?: Maybe<GameUpdateManyWithoutHostInput>;
  guestGames?: Maybe<GameUpdateManyWithoutGuestInput>;
  winnedGames?: Maybe<GameUpdateManyWithoutWinnerInput>;
}

export interface GameUpdateManyWithoutHostInput {
  create?: Maybe<GameCreateWithoutHostInput[] | GameCreateWithoutHostInput>;
  delete?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  connect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  set?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  disconnect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  update?: Maybe<
    | GameUpdateWithWhereUniqueWithoutHostInput[]
    | GameUpdateWithWhereUniqueWithoutHostInput
  >;
  upsert?: Maybe<
    | GameUpsertWithWhereUniqueWithoutHostInput[]
    | GameUpsertWithWhereUniqueWithoutHostInput
  >;
  deleteMany?: Maybe<GameScalarWhereInput[] | GameScalarWhereInput>;
  updateMany?: Maybe<
    GameUpdateManyWithWhereNestedInput[] | GameUpdateManyWithWhereNestedInput
  >;
}

export interface GameUpdateWithWhereUniqueWithoutHostInput {
  where: GameWhereUniqueInput;
  data: GameUpdateWithoutHostDataInput;
}

export interface GameUpdateWithoutHostDataInput {
  gameId?: Maybe<Int>;
  guest?: Maybe<AgentUpdateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map?: Maybe<GameMapUpdateOneRequiredInput>;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateUpdateOneInput>;
  winner?: Maybe<AgentUpdateOneWithoutWinnedGamesInput>;
  moves?: Maybe<MoveUpdateManyWithoutGameInput>;
}

export interface AgentUpdateOneWithoutGuestGamesInput {
  create?: Maybe<AgentCreateWithoutGuestGamesInput>;
  update?: Maybe<AgentUpdateWithoutGuestGamesDataInput>;
  upsert?: Maybe<AgentUpsertWithoutGuestGamesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentUpdateWithoutGuestGamesDataInput {
  name?: Maybe<String>;
  script?: Maybe<String>;
  className?: Maybe<String>;
  hostGames?: Maybe<GameUpdateManyWithoutHostInput>;
  winnedGames?: Maybe<GameUpdateManyWithoutWinnerInput>;
}

export interface GameUpdateManyWithoutWinnerInput {
  create?: Maybe<GameCreateWithoutWinnerInput[] | GameCreateWithoutWinnerInput>;
  delete?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  connect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  set?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  disconnect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  update?: Maybe<
    | GameUpdateWithWhereUniqueWithoutWinnerInput[]
    | GameUpdateWithWhereUniqueWithoutWinnerInput
  >;
  upsert?: Maybe<
    | GameUpsertWithWhereUniqueWithoutWinnerInput[]
    | GameUpsertWithWhereUniqueWithoutWinnerInput
  >;
  deleteMany?: Maybe<GameScalarWhereInput[] | GameScalarWhereInput>;
  updateMany?: Maybe<
    GameUpdateManyWithWhereNestedInput[] | GameUpdateManyWithWhereNestedInput
  >;
}

export interface GameUpdateWithWhereUniqueWithoutWinnerInput {
  where: GameWhereUniqueInput;
  data: GameUpdateWithoutWinnerDataInput;
}

export interface GameUpdateWithoutWinnerDataInput {
  gameId?: Maybe<Int>;
  host?: Maybe<AgentUpdateOneRequiredWithoutHostGamesInput>;
  guest?: Maybe<AgentUpdateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map?: Maybe<GameMapUpdateOneRequiredInput>;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateUpdateOneInput>;
  moves?: Maybe<MoveUpdateManyWithoutGameInput>;
}

export interface AgentUpdateOneRequiredWithoutHostGamesInput {
  create?: Maybe<AgentCreateWithoutHostGamesInput>;
  update?: Maybe<AgentUpdateWithoutHostGamesDataInput>;
  upsert?: Maybe<AgentUpsertWithoutHostGamesInput>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentUpdateWithoutHostGamesDataInput {
  name?: Maybe<String>;
  script?: Maybe<String>;
  className?: Maybe<String>;
  guestGames?: Maybe<GameUpdateManyWithoutGuestInput>;
  winnedGames?: Maybe<GameUpdateManyWithoutWinnerInput>;
}

export interface GameUpdateManyWithoutGuestInput {
  create?: Maybe<GameCreateWithoutGuestInput[] | GameCreateWithoutGuestInput>;
  delete?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  connect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  set?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  disconnect?: Maybe<GameWhereUniqueInput[] | GameWhereUniqueInput>;
  update?: Maybe<
    | GameUpdateWithWhereUniqueWithoutGuestInput[]
    | GameUpdateWithWhereUniqueWithoutGuestInput
  >;
  upsert?: Maybe<
    | GameUpsertWithWhereUniqueWithoutGuestInput[]
    | GameUpsertWithWhereUniqueWithoutGuestInput
  >;
  deleteMany?: Maybe<GameScalarWhereInput[] | GameScalarWhereInput>;
  updateMany?: Maybe<
    GameUpdateManyWithWhereNestedInput[] | GameUpdateManyWithWhereNestedInput
  >;
}

export interface GameUpdateWithWhereUniqueWithoutGuestInput {
  where: GameWhereUniqueInput;
  data: GameUpdateWithoutGuestDataInput;
}

export interface GameUpdateWithoutGuestDataInput {
  gameId?: Maybe<Int>;
  host?: Maybe<AgentUpdateOneRequiredWithoutHostGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map?: Maybe<GameMapUpdateOneRequiredInput>;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateUpdateOneInput>;
  winner?: Maybe<AgentUpdateOneWithoutWinnedGamesInput>;
  moves?: Maybe<MoveUpdateManyWithoutGameInput>;
}

export interface GameMapUpdateOneRequiredInput {
  create?: Maybe<GameMapCreateInput>;
  update?: Maybe<GameMapUpdateDataInput>;
  upsert?: Maybe<GameMapUpsertNestedInput>;
  connect?: Maybe<GameMapWhereUniqueInput>;
}

export interface GameMapUpdateDataInput {
  name?: Maybe<String>;
}

export interface GameMapUpsertNestedInput {
  update: GameMapUpdateDataInput;
  create: GameMapCreateInput;
}

export interface GameStateUpdateOneInput {
  create?: Maybe<GameStateCreateInput>;
  update?: Maybe<GameStateUpdateDataInput>;
  upsert?: Maybe<GameStateUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface GameStateUpdateDataInput {
  playerTurn?: Maybe<ID_Input>;
  map?: Maybe<MapUpdateOneRequiredInput>;
  player1?: Maybe<PlayerUpdateOneRequiredInput>;
  player2?: Maybe<PlayerUpdateOneRequiredInput>;
}

export interface MapUpdateOneRequiredInput {
  create?: Maybe<MapCreateInput>;
  update?: Maybe<MapUpdateDataInput>;
  upsert?: Maybe<MapUpsertNestedInput>;
}

export interface MapUpdateDataInput {
  tiles?: Maybe<TileUpdateManyInput>;
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export interface TileUpdateManyInput {
  create?: Maybe<TileCreateInput[] | TileCreateInput>;
  deleteMany?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
  updateMany?: Maybe<
    TileUpdateManyWithWhereNestedInput[] | TileUpdateManyWithWhereNestedInput
  >;
}

export interface TileScalarWhereInput {
  type?: Maybe<TileType>;
  type_not?: Maybe<TileType>;
  type_in?: Maybe<TileType[] | TileType>;
  type_not_in?: Maybe<TileType[] | TileType>;
  item?: Maybe<ItemType>;
  item_not?: Maybe<ItemType>;
  item_in?: Maybe<ItemType[] | ItemType>;
  item_not_in?: Maybe<ItemType[] | ItemType>;
  AND?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
  OR?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
  NOT?: Maybe<TileScalarWhereInput[] | TileScalarWhereInput>;
}

export interface TileUpdateManyWithWhereNestedInput {
  where: TileScalarWhereInput;
  data: TileUpdateManyDataInput;
}

export interface TileUpdateManyDataInput {
  type?: Maybe<TileType>;
  item?: Maybe<ItemType>;
}

export interface MapUpsertNestedInput {
  update: MapUpdateDataInput;
  create: MapCreateInput;
}

export interface PlayerUpdateOneRequiredInput {
  create?: Maybe<PlayerCreateInput>;
  update?: Maybe<PlayerUpdateDataInput>;
  upsert?: Maybe<PlayerUpsertNestedInput>;
}

export interface PlayerUpdateDataInput {
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  type?: Maybe<Morph>;
  morphItems?: Maybe<PlayerUpdatemorphItemsInput>;
  health?: Maybe<Int>;
  lives?: Maybe<Int>;
  lastAction?: Maybe<Action>;
}

export interface PlayerUpdatemorphItemsInput {
  set?: Maybe<Morph[] | Morph>;
}

export interface PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput;
  create: PlayerCreateInput;
}

export interface GameStateUpsertNestedInput {
  update: GameStateUpdateDataInput;
  create: GameStateCreateInput;
}

export interface AgentUpdateOneWithoutWinnedGamesInput {
  create?: Maybe<AgentCreateWithoutWinnedGamesInput>;
  update?: Maybe<AgentUpdateWithoutWinnedGamesDataInput>;
  upsert?: Maybe<AgentUpsertWithoutWinnedGamesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentUpdateWithoutWinnedGamesDataInput {
  name?: Maybe<String>;
  script?: Maybe<String>;
  className?: Maybe<String>;
  hostGames?: Maybe<GameUpdateManyWithoutHostInput>;
  guestGames?: Maybe<GameUpdateManyWithoutGuestInput>;
}

export interface AgentUpsertWithoutWinnedGamesInput {
  update: AgentUpdateWithoutWinnedGamesDataInput;
  create: AgentCreateWithoutWinnedGamesInput;
}

export interface MoveUpdateManyWithoutGameInput {
  create?: Maybe<MoveCreateWithoutGameInput[] | MoveCreateWithoutGameInput>;
  delete?: Maybe<MoveWhereUniqueInput[] | MoveWhereUniqueInput>;
  connect?: Maybe<MoveWhereUniqueInput[] | MoveWhereUniqueInput>;
  set?: Maybe<MoveWhereUniqueInput[] | MoveWhereUniqueInput>;
  disconnect?: Maybe<MoveWhereUniqueInput[] | MoveWhereUniqueInput>;
  update?: Maybe<
    | MoveUpdateWithWhereUniqueWithoutGameInput[]
    | MoveUpdateWithWhereUniqueWithoutGameInput
  >;
  upsert?: Maybe<
    | MoveUpsertWithWhereUniqueWithoutGameInput[]
    | MoveUpsertWithWhereUniqueWithoutGameInput
  >;
  deleteMany?: Maybe<MoveScalarWhereInput[] | MoveScalarWhereInput>;
  updateMany?: Maybe<
    MoveUpdateManyWithWhereNestedInput[] | MoveUpdateManyWithWhereNestedInput
  >;
}

export interface MoveUpdateWithWhereUniqueWithoutGameInput {
  where: MoveWhereUniqueInput;
  data: MoveUpdateWithoutGameDataInput;
}

export interface MoveUpdateWithoutGameDataInput {
  player?: Maybe<AgentUpdateOneRequiredInput>;
  action?: Maybe<Action>;
  actionType?: Maybe<ActionType>;
  state?: Maybe<GameStateUpdateOneRequiredInput>;
}

export interface AgentUpdateOneRequiredInput {
  create?: Maybe<AgentCreateInput>;
  update?: Maybe<AgentUpdateDataInput>;
  upsert?: Maybe<AgentUpsertNestedInput>;
  connect?: Maybe<AgentWhereUniqueInput>;
}

export interface AgentUpdateDataInput {
  name?: Maybe<String>;
  script?: Maybe<String>;
  className?: Maybe<String>;
  hostGames?: Maybe<GameUpdateManyWithoutHostInput>;
  guestGames?: Maybe<GameUpdateManyWithoutGuestInput>;
  winnedGames?: Maybe<GameUpdateManyWithoutWinnerInput>;
}

export interface AgentUpsertNestedInput {
  update: AgentUpdateDataInput;
  create: AgentCreateInput;
}

export interface GameStateUpdateOneRequiredInput {
  create?: Maybe<GameStateCreateInput>;
  update?: Maybe<GameStateUpdateDataInput>;
  upsert?: Maybe<GameStateUpsertNestedInput>;
}

export interface MoveUpsertWithWhereUniqueWithoutGameInput {
  where: MoveWhereUniqueInput;
  update: MoveUpdateWithoutGameDataInput;
  create: MoveCreateWithoutGameInput;
}

export interface MoveScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  action?: Maybe<Action>;
  action_not?: Maybe<Action>;
  action_in?: Maybe<Action[] | Action>;
  action_not_in?: Maybe<Action[] | Action>;
  actionType?: Maybe<ActionType>;
  actionType_not?: Maybe<ActionType>;
  actionType_in?: Maybe<ActionType[] | ActionType>;
  actionType_not_in?: Maybe<ActionType[] | ActionType>;
  AND?: Maybe<MoveScalarWhereInput[] | MoveScalarWhereInput>;
  OR?: Maybe<MoveScalarWhereInput[] | MoveScalarWhereInput>;
  NOT?: Maybe<MoveScalarWhereInput[] | MoveScalarWhereInput>;
}

export interface MoveUpdateManyWithWhereNestedInput {
  where: MoveScalarWhereInput;
  data: MoveUpdateManyDataInput;
}

export interface MoveUpdateManyDataInput {
  action?: Maybe<Action>;
  actionType?: Maybe<ActionType>;
}

export interface GameUpsertWithWhereUniqueWithoutGuestInput {
  where: GameWhereUniqueInput;
  update: GameUpdateWithoutGuestDataInput;
  create: GameCreateWithoutGuestInput;
}

export interface GameScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  gameId?: Maybe<Int>;
  gameId_not?: Maybe<Int>;
  gameId_in?: Maybe<Int[] | Int>;
  gameId_not_in?: Maybe<Int[] | Int>;
  gameId_lt?: Maybe<Int>;
  gameId_lte?: Maybe<Int>;
  gameId_gt?: Maybe<Int>;
  gameId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  playerOneId?: Maybe<ID_Input>;
  playerOneId_not?: Maybe<ID_Input>;
  playerOneId_in?: Maybe<ID_Input[] | ID_Input>;
  playerOneId_not_in?: Maybe<ID_Input[] | ID_Input>;
  playerOneId_lt?: Maybe<ID_Input>;
  playerOneId_lte?: Maybe<ID_Input>;
  playerOneId_gt?: Maybe<ID_Input>;
  playerOneId_gte?: Maybe<ID_Input>;
  playerOneId_contains?: Maybe<ID_Input>;
  playerOneId_not_contains?: Maybe<ID_Input>;
  playerOneId_starts_with?: Maybe<ID_Input>;
  playerOneId_not_starts_with?: Maybe<ID_Input>;
  playerOneId_ends_with?: Maybe<ID_Input>;
  playerOneId_not_ends_with?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  playerTwoId_not?: Maybe<ID_Input>;
  playerTwoId_in?: Maybe<ID_Input[] | ID_Input>;
  playerTwoId_not_in?: Maybe<ID_Input[] | ID_Input>;
  playerTwoId_lt?: Maybe<ID_Input>;
  playerTwoId_lte?: Maybe<ID_Input>;
  playerTwoId_gt?: Maybe<ID_Input>;
  playerTwoId_gte?: Maybe<ID_Input>;
  playerTwoId_contains?: Maybe<ID_Input>;
  playerTwoId_not_contains?: Maybe<ID_Input>;
  playerTwoId_starts_with?: Maybe<ID_Input>;
  playerTwoId_not_starts_with?: Maybe<ID_Input>;
  playerTwoId_ends_with?: Maybe<ID_Input>;
  playerTwoId_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<GameStatus>;
  status_not?: Maybe<GameStatus>;
  status_in?: Maybe<GameStatus[] | GameStatus>;
  status_not_in?: Maybe<GameStatus[] | GameStatus>;
  AND?: Maybe<GameScalarWhereInput[] | GameScalarWhereInput>;
  OR?: Maybe<GameScalarWhereInput[] | GameScalarWhereInput>;
  NOT?: Maybe<GameScalarWhereInput[] | GameScalarWhereInput>;
}

export interface GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput;
  data: GameUpdateManyDataInput;
}

export interface GameUpdateManyDataInput {
  gameId?: Maybe<Int>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  status?: Maybe<GameStatus>;
}

export interface AgentUpsertWithoutHostGamesInput {
  update: AgentUpdateWithoutHostGamesDataInput;
  create: AgentCreateWithoutHostGamesInput;
}

export interface GameUpsertWithWhereUniqueWithoutWinnerInput {
  where: GameWhereUniqueInput;
  update: GameUpdateWithoutWinnerDataInput;
  create: GameCreateWithoutWinnerInput;
}

export interface AgentUpsertWithoutGuestGamesInput {
  update: AgentUpdateWithoutGuestGamesDataInput;
  create: AgentCreateWithoutGuestGamesInput;
}

export interface GameUpsertWithWhereUniqueWithoutHostInput {
  where: GameWhereUniqueInput;
  update: GameUpdateWithoutHostDataInput;
  create: GameCreateWithoutHostInput;
}

export interface AgentUpdateManyMutationInput {
  name?: Maybe<String>;
  script?: Maybe<String>;
  className?: Maybe<String>;
}

export interface GameCreateInput {
  id?: Maybe<ID_Input>;
  gameId: Int;
  host: AgentCreateOneWithoutHostGamesInput;
  guest?: Maybe<AgentCreateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map: GameMapCreateOneInput;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateCreateOneInput>;
  winner?: Maybe<AgentCreateOneWithoutWinnedGamesInput>;
  moves?: Maybe<MoveCreateManyWithoutGameInput>;
}

export interface GameUpdateInput {
  gameId?: Maybe<Int>;
  host?: Maybe<AgentUpdateOneRequiredWithoutHostGamesInput>;
  guest?: Maybe<AgentUpdateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map?: Maybe<GameMapUpdateOneRequiredInput>;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateUpdateOneInput>;
  winner?: Maybe<AgentUpdateOneWithoutWinnedGamesInput>;
  moves?: Maybe<MoveUpdateManyWithoutGameInput>;
}

export interface GameUpdateManyMutationInput {
  gameId?: Maybe<Int>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  status?: Maybe<GameStatus>;
}

export interface GameMapUpdateInput {
  name?: Maybe<String>;
}

export interface GameMapUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface MoveCreateInput {
  id?: Maybe<ID_Input>;
  game: GameCreateOneWithoutMovesInput;
  player: AgentCreateOneInput;
  action?: Maybe<Action>;
  actionType?: Maybe<ActionType>;
  state: GameStateCreateOneInput;
}

export interface GameCreateOneWithoutMovesInput {
  create?: Maybe<GameCreateWithoutMovesInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface GameCreateWithoutMovesInput {
  id?: Maybe<ID_Input>;
  gameId: Int;
  host: AgentCreateOneWithoutHostGamesInput;
  guest?: Maybe<AgentCreateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map: GameMapCreateOneInput;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateCreateOneInput>;
  winner?: Maybe<AgentCreateOneWithoutWinnedGamesInput>;
}

export interface MoveUpdateInput {
  game?: Maybe<GameUpdateOneRequiredWithoutMovesInput>;
  player?: Maybe<AgentUpdateOneRequiredInput>;
  action?: Maybe<Action>;
  actionType?: Maybe<ActionType>;
  state?: Maybe<GameStateUpdateOneRequiredInput>;
}

export interface GameUpdateOneRequiredWithoutMovesInput {
  create?: Maybe<GameCreateWithoutMovesInput>;
  update?: Maybe<GameUpdateWithoutMovesDataInput>;
  upsert?: Maybe<GameUpsertWithoutMovesInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface GameUpdateWithoutMovesDataInput {
  gameId?: Maybe<Int>;
  host?: Maybe<AgentUpdateOneRequiredWithoutHostGamesInput>;
  guest?: Maybe<AgentUpdateOneWithoutGuestGamesInput>;
  playerOneId?: Maybe<ID_Input>;
  playerTwoId?: Maybe<ID_Input>;
  map?: Maybe<GameMapUpdateOneRequiredInput>;
  status?: Maybe<GameStatus>;
  state?: Maybe<GameStateUpdateOneInput>;
  winner?: Maybe<AgentUpdateOneWithoutWinnedGamesInput>;
}

export interface GameUpsertWithoutMovesInput {
  update: GameUpdateWithoutMovesDataInput;
  create: GameCreateWithoutMovesInput;
}

export interface MoveUpdateManyMutationInput {
  action?: Maybe<Action>;
  actionType?: Maybe<ActionType>;
}

export interface WorkgroupCreateInput {
  id?: Maybe<ID_Input>;
  workstation: WorkstationCreateOneWithoutWorkgroupsInput;
  busy?: Maybe<Boolean>;
}

export interface WorkstationCreateOneWithoutWorkgroupsInput {
  create?: Maybe<WorkstationCreateWithoutWorkgroupsInput>;
  connect?: Maybe<WorkstationWhereUniqueInput>;
}

export interface WorkstationCreateWithoutWorkgroupsInput {
  id?: Maybe<ID_Input>;
  name: String;
  url: String;
  privateKey: String;
}

export interface WorkgroupUpdateInput {
  workstation?: Maybe<WorkstationUpdateOneRequiredWithoutWorkgroupsInput>;
  busy?: Maybe<Boolean>;
}

export interface WorkstationUpdateOneRequiredWithoutWorkgroupsInput {
  create?: Maybe<WorkstationCreateWithoutWorkgroupsInput>;
  update?: Maybe<WorkstationUpdateWithoutWorkgroupsDataInput>;
  upsert?: Maybe<WorkstationUpsertWithoutWorkgroupsInput>;
  connect?: Maybe<WorkstationWhereUniqueInput>;
}

export interface WorkstationUpdateWithoutWorkgroupsDataInput {
  name?: Maybe<String>;
  url?: Maybe<String>;
  privateKey?: Maybe<String>;
}

export interface WorkstationUpsertWithoutWorkgroupsInput {
  update: WorkstationUpdateWithoutWorkgroupsDataInput;
  create: WorkstationCreateWithoutWorkgroupsInput;
}

export interface WorkgroupUpdateManyMutationInput {
  busy?: Maybe<Boolean>;
}

export interface WorkstationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  url: String;
  privateKey: String;
  workgroups?: Maybe<WorkgroupCreateManyWithoutWorkstationInput>;
}

export interface WorkgroupCreateManyWithoutWorkstationInput {
  create?: Maybe<
    | WorkgroupCreateWithoutWorkstationInput[]
    | WorkgroupCreateWithoutWorkstationInput
  >;
  connect?: Maybe<WorkgroupWhereUniqueInput[] | WorkgroupWhereUniqueInput>;
}

export interface WorkgroupCreateWithoutWorkstationInput {
  id?: Maybe<ID_Input>;
  busy?: Maybe<Boolean>;
}

export interface WorkstationUpdateInput {
  name?: Maybe<String>;
  url?: Maybe<String>;
  privateKey?: Maybe<String>;
  workgroups?: Maybe<WorkgroupUpdateManyWithoutWorkstationInput>;
}

export interface WorkgroupUpdateManyWithoutWorkstationInput {
  create?: Maybe<
    | WorkgroupCreateWithoutWorkstationInput[]
    | WorkgroupCreateWithoutWorkstationInput
  >;
  delete?: Maybe<WorkgroupWhereUniqueInput[] | WorkgroupWhereUniqueInput>;
  connect?: Maybe<WorkgroupWhereUniqueInput[] | WorkgroupWhereUniqueInput>;
  set?: Maybe<WorkgroupWhereUniqueInput[] | WorkgroupWhereUniqueInput>;
  disconnect?: Maybe<WorkgroupWhereUniqueInput[] | WorkgroupWhereUniqueInput>;
  update?: Maybe<
    | WorkgroupUpdateWithWhereUniqueWithoutWorkstationInput[]
    | WorkgroupUpdateWithWhereUniqueWithoutWorkstationInput
  >;
  upsert?: Maybe<
    | WorkgroupUpsertWithWhereUniqueWithoutWorkstationInput[]
    | WorkgroupUpsertWithWhereUniqueWithoutWorkstationInput
  >;
  deleteMany?: Maybe<WorkgroupScalarWhereInput[] | WorkgroupScalarWhereInput>;
  updateMany?: Maybe<
    | WorkgroupUpdateManyWithWhereNestedInput[]
    | WorkgroupUpdateManyWithWhereNestedInput
  >;
}

export interface WorkgroupUpdateWithWhereUniqueWithoutWorkstationInput {
  where: WorkgroupWhereUniqueInput;
  data: WorkgroupUpdateWithoutWorkstationDataInput;
}

export interface WorkgroupUpdateWithoutWorkstationDataInput {
  busy?: Maybe<Boolean>;
}

export interface WorkgroupUpsertWithWhereUniqueWithoutWorkstationInput {
  where: WorkgroupWhereUniqueInput;
  update: WorkgroupUpdateWithoutWorkstationDataInput;
  create: WorkgroupCreateWithoutWorkstationInput;
}

export interface WorkgroupScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  busy?: Maybe<Boolean>;
  busy_not?: Maybe<Boolean>;
  AND?: Maybe<WorkgroupScalarWhereInput[] | WorkgroupScalarWhereInput>;
  OR?: Maybe<WorkgroupScalarWhereInput[] | WorkgroupScalarWhereInput>;
  NOT?: Maybe<WorkgroupScalarWhereInput[] | WorkgroupScalarWhereInput>;
}

export interface WorkgroupUpdateManyWithWhereNestedInput {
  where: WorkgroupScalarWhereInput;
  data: WorkgroupUpdateManyDataInput;
}

export interface WorkgroupUpdateManyDataInput {
  busy?: Maybe<Boolean>;
}

export interface WorkstationUpdateManyMutationInput {
  name?: Maybe<String>;
  url?: Maybe<String>;
  privateKey?: Maybe<String>;
}

export interface AgentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AgentWhereInput>;
  AND?: Maybe<AgentSubscriptionWhereInput[] | AgentSubscriptionWhereInput>;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameWhereInput>;
  AND?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
}

export interface GameMapSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameMapWhereInput>;
  AND?: Maybe<GameMapSubscriptionWhereInput[] | GameMapSubscriptionWhereInput>;
}

export interface MoveSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MoveWhereInput>;
  AND?: Maybe<MoveSubscriptionWhereInput[] | MoveSubscriptionWhereInput>;
}

export interface WorkgroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkgroupWhereInput>;
  AND?: Maybe<
    WorkgroupSubscriptionWhereInput[] | WorkgroupSubscriptionWhereInput
  >;
}

export interface WorkstationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkstationWhereInput>;
  AND?: Maybe<
    WorkstationSubscriptionWhereInput[] | WorkstationSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Agent {
  id: ID_Output;
  name: String;
  script?: String;
  className?: String;
}

export interface AgentPromise extends Promise<Agent>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  script: () => Promise<String>;
  className: () => Promise<String>;
  hostGames: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  guestGames: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  winnedGames: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AgentSubscription
  extends Promise<AsyncIterator<Agent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  script: () => Promise<AsyncIterator<String>>;
  className: () => Promise<AsyncIterator<String>>;
  hostGames: <T = Promise<AsyncIterator<GameSubscription>>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  guestGames: <T = Promise<AsyncIterator<GameSubscription>>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  winnedGames: <T = Promise<AsyncIterator<GameSubscription>>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AgentNullablePromise
  extends Promise<Agent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  script: () => Promise<String>;
  className: () => Promise<String>;
  hostGames: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  guestGames: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  winnedGames: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Game {
  id: ID_Output;
  gameId: Int;
  createdAt: DateTimeOutput;
  playerOneId?: ID_Output;
  playerTwoId?: ID_Output;
  status: GameStatus;
  state?: GameState | null;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  gameId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  host: <T = AgentPromise>() => T;
  guest: <T = AgentPromise>() => T;
  playerOneId: () => Promise<ID_Output>;
  playerTwoId: () => Promise<ID_Output>;
  map: <T = GameMapPromise>() => T;
  status: () => Promise<GameStatus>;
  state: <T = GameStatePromise>() => T;
  winner: <T = AgentPromise>() => T;
  moves: <T = FragmentableArray<Move>>(args?: {
    where?: MoveWhereInput;
    orderBy?: MoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  gameId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  host: <T = AgentSubscription>() => T;
  guest: <T = AgentSubscription>() => T;
  playerOneId: () => Promise<AsyncIterator<ID_Output>>;
  playerTwoId: () => Promise<AsyncIterator<ID_Output>>;
  map: <T = GameMapSubscription>() => T;
  status: () => Promise<AsyncIterator<GameStatus>>;
  state: <T = GameStateSubscription>() => T;
  winner: <T = AgentSubscription>() => T;
  moves: <T = Promise<AsyncIterator<MoveSubscription>>>(args?: {
    where?: MoveWhereInput;
    orderBy?: MoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GameNullablePromise
  extends Promise<Game | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  gameId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  host: <T = AgentPromise>() => T;
  guest: <T = AgentPromise>() => T;
  playerOneId: () => Promise<ID_Output>;
  playerTwoId: () => Promise<ID_Output>;
  map: <T = GameMapPromise>() => T;
  status: () => Promise<GameStatus>;
  state: <T = GameStatePromise>() => T;
  winner: <T = AgentPromise>() => T;
  moves: <T = FragmentableArray<Move>>(args?: {
    where?: MoveWhereInput;
    orderBy?: MoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GameMap {
  id: ID_Output;
  name: String;
}

export interface GameMapPromise extends Promise<GameMap>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface GameMapSubscription
  extends Promise<AsyncIterator<GameMap>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GameMapNullablePromise
  extends Promise<GameMap | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface GameState {
  playerTurn: ID_Output;
  map: Map;
  player1: Player;
  player2: Player;
}

export interface GameStatePromise extends Promise<GameState>, Fragmentable {
  playerTurn: () => Promise<ID_Output>;
  map: <T = MapPromise>() => T;
  player1: <T = PlayerPromise>() => T;
  player2: <T = PlayerPromise>() => T;
}

export interface GameStateSubscription
  extends Promise<AsyncIterator<GameState>>,
    Fragmentable {
  playerTurn: () => Promise<AsyncIterator<ID_Output>>;
  map: <T = MapSubscription>() => T;
  player1: <T = PlayerSubscription>() => T;
  player2: <T = PlayerSubscription>() => T;
}

export interface GameStateNullablePromise
  extends Promise<GameState | null>,
    Fragmentable {
  playerTurn: () => Promise<ID_Output>;
  map: <T = MapPromise>() => T;
  player1: <T = PlayerPromise>() => T;
  player2: <T = PlayerPromise>() => T;
}

export interface Map {
  tiles?: <T = FragmentableArray<Tile>>() => T;
  width: Int;
  height: Int;
}

export interface MapPromise extends Promise<Map>, Fragmentable {
  tiles: <T = FragmentableArray<Tile>>() => T;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface MapSubscription
  extends Promise<AsyncIterator<Map>>,
    Fragmentable {
  tiles: <T = Promise<AsyncIterator<TileSubscription>>>() => T;
  width: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
}

export interface MapNullablePromise extends Promise<Map | null>, Fragmentable {
  tiles: <T = FragmentableArray<Tile>>() => T;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface Tile {
  type: TileType;
  item?: ItemType;
}

export interface TilePromise extends Promise<Tile>, Fragmentable {
  type: () => Promise<TileType>;
  item: () => Promise<ItemType>;
}

export interface TileSubscription
  extends Promise<AsyncIterator<Tile>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<TileType>>;
  item: () => Promise<AsyncIterator<ItemType>>;
}

export interface TileNullablePromise
  extends Promise<Tile | null>,
    Fragmentable {
  type: () => Promise<TileType>;
  item: () => Promise<ItemType>;
}

export interface Player {
  x: Int;
  y: Int;
  type: Morph;
  morphItems: Morph[];
  health: Int;
  lives: Int;
  lastAction?: Action;
}

export interface PlayerPromise extends Promise<Player>, Fragmentable {
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  type: () => Promise<Morph>;
  morphItems: () => Promise<Morph[]>;
  health: () => Promise<Int>;
  lives: () => Promise<Int>;
  lastAction: () => Promise<Action>;
}

export interface PlayerSubscription
  extends Promise<AsyncIterator<Player>>,
    Fragmentable {
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Morph>>;
  morphItems: () => Promise<AsyncIterator<Morph[]>>;
  health: () => Promise<AsyncIterator<Int>>;
  lives: () => Promise<AsyncIterator<Int>>;
  lastAction: () => Promise<AsyncIterator<Action>>;
}

export interface PlayerNullablePromise
  extends Promise<Player | null>,
    Fragmentable {
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  type: () => Promise<Morph>;
  morphItems: () => Promise<Morph[]>;
  health: () => Promise<Int>;
  lives: () => Promise<Int>;
  lastAction: () => Promise<Action>;
}

export interface Move {
  id: ID_Output;
  action?: Action;
  actionType?: ActionType;
  state: GameState;
}

export interface MovePromise extends Promise<Move>, Fragmentable {
  id: () => Promise<ID_Output>;
  game: <T = GamePromise>() => T;
  player: <T = AgentPromise>() => T;
  action: () => Promise<Action>;
  actionType: () => Promise<ActionType>;
  state: <T = GameStatePromise>() => T;
}

export interface MoveSubscription
  extends Promise<AsyncIterator<Move>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  game: <T = GameSubscription>() => T;
  player: <T = AgentSubscription>() => T;
  action: () => Promise<AsyncIterator<Action>>;
  actionType: () => Promise<AsyncIterator<ActionType>>;
  state: <T = GameStateSubscription>() => T;
}

export interface MoveNullablePromise
  extends Promise<Move | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  game: <T = GamePromise>() => T;
  player: <T = AgentPromise>() => T;
  action: () => Promise<Action>;
  actionType: () => Promise<ActionType>;
  state: <T = GameStatePromise>() => T;
}

export interface AgentConnection {
  pageInfo: PageInfo;
  edges: AgentEdge[];
}

export interface AgentConnectionPromise
  extends Promise<AgentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgentEdge>>() => T;
  aggregate: <T = AggregateAgentPromise>() => T;
}

export interface AgentConnectionSubscription
  extends Promise<AsyncIterator<AgentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AgentEdge {
  node: Agent;
  cursor: String;
}

export interface AgentEdgePromise extends Promise<AgentEdge>, Fragmentable {
  node: <T = AgentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgentEdgeSubscription
  extends Promise<AsyncIterator<AgentEdge>>,
    Fragmentable {
  node: <T = AgentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgent {
  count: Int;
}

export interface AggregateAgentPromise
  extends Promise<AggregateAgent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgentSubscription
  extends Promise<AsyncIterator<AggregateAgent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GameMapConnection {
  pageInfo: PageInfo;
  edges: GameMapEdge[];
}

export interface GameMapConnectionPromise
  extends Promise<GameMapConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameMapEdge>>() => T;
  aggregate: <T = AggregateGameMapPromise>() => T;
}

export interface GameMapConnectionSubscription
  extends Promise<AsyncIterator<GameMapConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameMapEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameMapSubscription>() => T;
}

export interface GameMapEdge {
  node: GameMap;
  cursor: String;
}

export interface GameMapEdgePromise extends Promise<GameMapEdge>, Fragmentable {
  node: <T = GameMapPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameMapEdgeSubscription
  extends Promise<AsyncIterator<GameMapEdge>>,
    Fragmentable {
  node: <T = GameMapSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGameMap {
  count: Int;
}

export interface AggregateGameMapPromise
  extends Promise<AggregateGameMap>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameMapSubscription
  extends Promise<AsyncIterator<AggregateGameMap>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MoveConnection {
  pageInfo: PageInfo;
  edges: MoveEdge[];
}

export interface MoveConnectionPromise
  extends Promise<MoveConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MoveEdge>>() => T;
  aggregate: <T = AggregateMovePromise>() => T;
}

export interface MoveConnectionSubscription
  extends Promise<AsyncIterator<MoveConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MoveEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMoveSubscription>() => T;
}

export interface MoveEdge {
  node: Move;
  cursor: String;
}

export interface MoveEdgePromise extends Promise<MoveEdge>, Fragmentable {
  node: <T = MovePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MoveEdgeSubscription
  extends Promise<AsyncIterator<MoveEdge>>,
    Fragmentable {
  node: <T = MoveSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMove {
  count: Int;
}

export interface AggregateMovePromise
  extends Promise<AggregateMove>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMoveSubscription
  extends Promise<AsyncIterator<AggregateMove>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Workgroup {
  id: ID_Output;
  busy: Boolean;
}

export interface WorkgroupPromise extends Promise<Workgroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  workstation: <T = WorkstationPromise>() => T;
  busy: () => Promise<Boolean>;
}

export interface WorkgroupSubscription
  extends Promise<AsyncIterator<Workgroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  workstation: <T = WorkstationSubscription>() => T;
  busy: () => Promise<AsyncIterator<Boolean>>;
}

export interface WorkgroupNullablePromise
  extends Promise<Workgroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  workstation: <T = WorkstationPromise>() => T;
  busy: () => Promise<Boolean>;
}

export interface Workstation {
  id: ID_Output;
  name: String;
  url: String;
  privateKey: String;
}

export interface WorkstationPromise extends Promise<Workstation>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  url: () => Promise<String>;
  privateKey: () => Promise<String>;
  workgroups: <T = FragmentableArray<Workgroup>>(args?: {
    where?: WorkgroupWhereInput;
    orderBy?: WorkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkstationSubscription
  extends Promise<AsyncIterator<Workstation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  privateKey: () => Promise<AsyncIterator<String>>;
  workgroups: <T = Promise<AsyncIterator<WorkgroupSubscription>>>(args?: {
    where?: WorkgroupWhereInput;
    orderBy?: WorkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkstationNullablePromise
  extends Promise<Workstation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  url: () => Promise<String>;
  privateKey: () => Promise<String>;
  workgroups: <T = FragmentableArray<Workgroup>>(args?: {
    where?: WorkgroupWhereInput;
    orderBy?: WorkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkgroupConnection {
  pageInfo: PageInfo;
  edges: WorkgroupEdge[];
}

export interface WorkgroupConnectionPromise
  extends Promise<WorkgroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkgroupEdge>>() => T;
  aggregate: <T = AggregateWorkgroupPromise>() => T;
}

export interface WorkgroupConnectionSubscription
  extends Promise<AsyncIterator<WorkgroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkgroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkgroupSubscription>() => T;
}

export interface WorkgroupEdge {
  node: Workgroup;
  cursor: String;
}

export interface WorkgroupEdgePromise
  extends Promise<WorkgroupEdge>,
    Fragmentable {
  node: <T = WorkgroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkgroupEdgeSubscription
  extends Promise<AsyncIterator<WorkgroupEdge>>,
    Fragmentable {
  node: <T = WorkgroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkgroup {
  count: Int;
}

export interface AggregateWorkgroupPromise
  extends Promise<AggregateWorkgroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkgroupSubscription
  extends Promise<AsyncIterator<AggregateWorkgroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkstationConnection {
  pageInfo: PageInfo;
  edges: WorkstationEdge[];
}

export interface WorkstationConnectionPromise
  extends Promise<WorkstationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkstationEdge>>() => T;
  aggregate: <T = AggregateWorkstationPromise>() => T;
}

export interface WorkstationConnectionSubscription
  extends Promise<AsyncIterator<WorkstationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkstationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkstationSubscription>() => T;
}

export interface WorkstationEdge {
  node: Workstation;
  cursor: String;
}

export interface WorkstationEdgePromise
  extends Promise<WorkstationEdge>,
    Fragmentable {
  node: <T = WorkstationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkstationEdgeSubscription
  extends Promise<AsyncIterator<WorkstationEdge>>,
    Fragmentable {
  node: <T = WorkstationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkstation {
  count: Int;
}

export interface AggregateWorkstationPromise
  extends Promise<AggregateWorkstation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkstationSubscription
  extends Promise<AsyncIterator<AggregateWorkstation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AgentSubscriptionPayload {
  mutation: MutationType;
  node: Agent;
  updatedFields: String[];
  previousValues: AgentPreviousValues;
}

export interface AgentSubscriptionPayloadPromise
  extends Promise<AgentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgentPreviousValuesPromise>() => T;
}

export interface AgentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgentPreviousValuesSubscription>() => T;
}

export interface AgentPreviousValues {
  id: ID_Output;
  name: String;
  script?: String;
  className?: String;
}

export interface AgentPreviousValuesPromise
  extends Promise<AgentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  script: () => Promise<String>;
  className: () => Promise<String>;
}

export interface AgentPreviousValuesSubscription
  extends Promise<AsyncIterator<AgentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  script: () => Promise<AsyncIterator<String>>;
  className: () => Promise<AsyncIterator<String>>;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface GamePreviousValues {
  id: ID_Output;
  gameId: Int;
  createdAt: DateTimeOutput;
  playerOneId?: ID_Output;
  playerTwoId?: ID_Output;
  status: GameStatus;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  gameId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  playerOneId: () => Promise<ID_Output>;
  playerTwoId: () => Promise<ID_Output>;
  status: () => Promise<GameStatus>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  gameId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  playerOneId: () => Promise<AsyncIterator<ID_Output>>;
  playerTwoId: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<GameStatus>>;
}

export interface GameMapSubscriptionPayload {
  mutation: MutationType;
  node: GameMap;
  updatedFields: String[];
  previousValues: GameMapPreviousValues;
}

export interface GameMapSubscriptionPayloadPromise
  extends Promise<GameMapSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GameMapPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GameMapPreviousValuesPromise>() => T;
}

export interface GameMapSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameMapSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameMapSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GameMapPreviousValuesSubscription>() => T;
}

export interface GameMapPreviousValues {
  id: ID_Output;
  name: String;
}

export interface GameMapPreviousValuesPromise
  extends Promise<GameMapPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface GameMapPreviousValuesSubscription
  extends Promise<AsyncIterator<GameMapPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface MoveSubscriptionPayload {
  mutation: MutationType;
  node: Move;
  updatedFields: String[];
  previousValues: MovePreviousValues;
}

export interface MoveSubscriptionPayloadPromise
  extends Promise<MoveSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MovePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MovePreviousValuesPromise>() => T;
}

export interface MoveSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MoveSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MoveSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MovePreviousValuesSubscription>() => T;
}

export interface MovePreviousValues {
  id: ID_Output;
  action?: Action;
  actionType?: ActionType;
}

export interface MovePreviousValuesPromise
  extends Promise<MovePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  action: () => Promise<Action>;
  actionType: () => Promise<ActionType>;
}

export interface MovePreviousValuesSubscription
  extends Promise<AsyncIterator<MovePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  action: () => Promise<AsyncIterator<Action>>;
  actionType: () => Promise<AsyncIterator<ActionType>>;
}

export interface WorkgroupSubscriptionPayload {
  mutation: MutationType;
  node: Workgroup;
  updatedFields: String[];
  previousValues: WorkgroupPreviousValues;
}

export interface WorkgroupSubscriptionPayloadPromise
  extends Promise<WorkgroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkgroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkgroupPreviousValuesPromise>() => T;
}

export interface WorkgroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkgroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkgroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkgroupPreviousValuesSubscription>() => T;
}

export interface WorkgroupPreviousValues {
  id: ID_Output;
  busy: Boolean;
}

export interface WorkgroupPreviousValuesPromise
  extends Promise<WorkgroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  busy: () => Promise<Boolean>;
}

export interface WorkgroupPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkgroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  busy: () => Promise<AsyncIterator<Boolean>>;
}

export interface WorkstationSubscriptionPayload {
  mutation: MutationType;
  node: Workstation;
  updatedFields: String[];
  previousValues: WorkstationPreviousValues;
}

export interface WorkstationSubscriptionPayloadPromise
  extends Promise<WorkstationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkstationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkstationPreviousValuesPromise>() => T;
}

export interface WorkstationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkstationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkstationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkstationPreviousValuesSubscription>() => T;
}

export interface WorkstationPreviousValues {
  id: ID_Output;
  name: String;
  url: String;
  privateKey: String;
}

export interface WorkstationPreviousValuesPromise
  extends Promise<WorkstationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  url: () => Promise<String>;
  privateKey: () => Promise<String>;
}

export interface WorkstationPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkstationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  privateKey: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Agent",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "GameMap",
    embedded: false
  },
  {
    name: "GameStatus",
    embedded: false
  },
  {
    name: "Move",
    embedded: false
  },
  {
    name: "Action",
    embedded: false
  },
  {
    name: "ActionType",
    embedded: false
  },
  {
    name: "Map",
    embedded: true
  },
  {
    name: "GameState",
    embedded: true
  },
  {
    name: "Tile",
    embedded: true
  },
  {
    name: "TileType",
    embedded: false
  },
  {
    name: "ItemType",
    embedded: false
  },
  {
    name: "Player",
    embedded: true
  },
  {
    name: "Morph",
    embedded: false
  },
  {
    name: "Workstation",
    embedded: false
  },
  {
    name: "Workgroup",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
